<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="stylesheet" href="../_static/template.css">
<link rel="stylesheet" href="../_static/mine.css">
<link rel="stylesheet" href="../_static/code.css">
<link rel="stylesheet" href="../_static/colors.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/dockerfile.min.js"></script>


<script>hljs.highlightAll();</script>
<title>Sprint4</title>
</head>
    
<body>

<div id="top">

    <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font> </h1>

</div>  

<div class="body"> 

    
<h2>Introduction</h2>

      
<div class="remark" id="intro">
    <p>
        In questo Sprint verrà analizzata la <b>ServiceStatusGUI</b>, componente software per permettere ad un utente umano di supervisionare lo stato della ServiceStatusGUI.
        <p class="nota">
            Ci poniamo già in un contesto in cui la <i>ServiceStatusGUI</i> sarà un'applicazione web realizzata tramite il framework <i>SpringBoot</i>, sia per uniformare lo stack tecnologico (<a href="../Sprint1/ServiceAccessGUISimProjectV1.html">ServiceAccessGUI</a>, <a href="../Sprint1/MapConfiguratorProject.html">MapConfigurator</a>), sia per diminuizione dei costi.
        </p>
    </p>
</div>


<h2>Requirements</h2>
 
<div class="remark">
    <p>
        <a target="_blank" href="https://iss.riccardob.dev/TemaFinale23.html">Descrizione requirements a questa pagina</a><br>
    </p>

    <p>
    <bc id="goals">Goals dello Sprint4</bc>:
    La <i>ServiceStatusGUI</i> dovrà mostrare:
    <ol>
        <li>il <b>peso attuale</b> del materiale immagazzinato nella ColdRoom</li>
        <li>il numero di <b>richieste di deposito rifiutate</b> dall'inizio del servizio</li>
        <li>lo <b>stato corrente</b> del <i>TransportTrolley</i> e la sua <b>posizione</b> nella stanza</li>
    </ol>
    </p>
    
</div>


<h2>Requirement analysis</h2>

<div class="remark">

    <p>
        Viene riportato nel <a href="../documents/temafinale_sprint4.pdf" target="_blank" rel="noopener noreferrer">seguente documento</a> la versione del <i>TemaFinale23</i> analizzata contestualmente a questo Sprint.
    </p>

    <p class="nota">
        Questo componente è alieno al progetto core del sistema (<i>qak</i>), non è per cui necessario, per ora, riportarne il modello architetturale.
    </p>

    <p>
        Mentre i primi 2 requisiti risultano molto chiari, il terzo viene analizzato di seguito.
    </p>

    <h5>Stato corrente del <i>TT</i> e <b>posizione</b></h5>
    <p>
        Dopo il colloqui con il committente, abbiamo chiarito che con <b>stato corrente</b> del <i>TransportTrolley</i> si intende l'informazione che sia:
        <ul>
            <li>fermo</li>
            <li>in movimento</li>
        </ul>
        Mentre, per la <b>posizione</b>, dobbiamo fornire l'informazione <i>relativamente alla stanza che naviga</i>. <br>
        Questo significa fornire all'utente anche una sorta di <u>rappresentazione della stanza</u> per dare un senso alla <i>posizione</i> del robot.
    </p>
</div>

<h2>Problem analysis</h2>

<div class="remark">
    <p class="keypoint">
        <b>KEY-POINT:</b> ricordiamo che, come detto in <a href="#intro">introduzione</a>, la <i>ServiceStatusGUI</i> sarà un'applicazione web in <b>Spring</b>
    </p>

    <p>
        Di seguito, verranno analizzati i 3 requisiti presenti in <a href="#goals">Requirements</a>.
    </p>
    <h5>Visualizzazione del <u>peso attuale</u> del materiale immagazzinato nella ColdRoom</h5>

    <p>
        Questa funzionalità è già stata implementata per la <i>ServiceAccessGUI</i> all'interno di <a href="../../docs/Sprint2/ColdStorageServiceSprint2V0.html#stato_coldRoom" target="_blank" rel="noopener noreferrer">questa sezione</a> dello <i>Sprint2</i>, per cui, vista anche l'uniformità dello stack tecnologico, non ci dilungheremo. <br>
        Oltre al concetto di <b>osservabilità</b> (analogo), per quanto riguarda l'inizializzazione verrà utilizzata la stessa <i>request-reply</i> della <i>ServiceAccessGUI</i>, che riportiamo di seguito.
        
        <table>
            <thead>
                <tr>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Tipologia interazione/messaggio</th>
                    <th>Identificatore messaggio</th>
                    <th>Payload</th>
                    <th>Descrizione</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="orange bold center">ServiceStatusGUI</td>
                    <td class="orange bold center">coldstorageservice</td>
                    <td class="blue bold center">Request</td>
                    <td>initcoldroom</td>
                    <td>initcoldroom()</td>
                    <td>Richiesta del valore attuale della ColdRoom.</td>
                </tr>
                <tr>
                    <td class="orange bold center">coldstorageservice</td>
                    <td class="orange bold center">ServiceStatusGUI</td>
                    <td class="blue bold center">Reply</td>
                    <td>coldroom</td>
                    <td>coldroom(ACTUAL,TEMP)</td>
                    <td>Valore di kg nella ColdRoom effettivi e totali (contando anche quelli in coda).</td>
                </tr>
            </tbody>
        </table>
    
    </p>

    <h5>Visualizzazione del numero di <u>richieste di deposito rifiutate</u> dall'inizio del servizio</h5>
    <p>
        Analogamante alla visualizzazione del peso immagazzinato nella ColdRoom, sfruttiamo l'<b>osservabilità</b> degli attori <i>qak</i> ed il protocollo <b>Coap</b>. L'attore <i>coldstorageservice</i>, che gestisce le richieste di deposito, emetterà un <b>event</b> (<i>updateResuource</i>) con il valore aggiornato del numero di richieste rifiutare e la <i>SSG</i> si sottoscriverà come osservatore.  <br>
        Anche qui, non ci dilungheremo ulteriormente.

        <p class="nota">
            <b>COMMITTENTE:</b> valutare l'interesse di fornire, a costo praticamente nullo, anche l'info su quelle rifutate per via di errori nell'inserimento del ticket.
        </p>
    </p>

    <h5>Visualizzazione <u>stato corrente</u> del <i>TT</i> e <u>posizione</u> nella ColdRoom</h5>

    <p>
        Anche qui, ci si basa sul concetto di osservabilità discusso appena sopra.
    </p>

    <p>
        Per entrambi i requisiti (stato e posizione), deleghiamoo l'emissione dell'evento contenente le informazioni al <i>TransportTrolley</i>, ovvero colui che realizza la logica di movimento.
    </p>
    <p>
        All'interno di <a href="../Sprint1/ColdStorageServiceSprint1V1.html#basicRobot_analisi" target="_blank" rel="noopener noreferrer">questa sezione</a> dello <i>Sprint1</i> sono presenti tutte le interazioni tra <i>TransportTrolley</i>, <i>TrolleyExecutor</i> e <i>BasicRobot</i>. Riportiamo di seguito solo quelle di interesse.
        <table>
            <thead>
                <tr>
                    <th>Mittente</th>
                    <th>Destinatario</th>
                    <th>Tipologia messaggio</th>
                    <th>Identificatore</th>
                    <th>Payload</th>
                    <th>Significato</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="orange bold center">transporttrolley</td>
                    <td class="orange bold center">trolleyexecutor</td>
                    <td class="blue bold center">Request</td>
                    <td>move</td>
                    <td>move(X, Y)</td>
                    <td>Il TT comunica al TE le coordinate verso cui effettuare lo spostamento</td>
                </tr>
                <tr>
                    <td class="orange bold center">trolleyexecutor</td>
                    <td class="orange bold center">transporttrolley</td>
                    <td class="blue bold center">Reply</td>
                    <td>movedone</td>
                    <td>movedone()</td>
                    <td>Lo spostamento è andato a buon fine</td>
                </tr>
                <tr>
                    <td class="orange bold center">trolleyexecutor</td>
                    <td class="orange bold center">transporttrolley</td>
                    <td class="blue bold center">Reply</td>
                    <td>movefailed</td>
                    <td>movefailed()</td>
                    <td>Lo spostamento NON è andato a buon fine</td>
                </tr>
            </tbody>
        </table>
    </p>
    <p class="nota">
        Abbiamo omesso l'interazione <i>moveclosest</i> per ridondanza e comodità di visualizzazione.
    </p>
    <p>
        Il <i>TransportTrolley</i> è il solo ad avere in pancia tutte le informazioni necessarie. In particolare, sa se il robot è in movimento o meno grazie all'interazione <i>move/moveclosest</i>: sarà necessario emettere un evento "movimento" alla richiesta <i>move</i> ed un altro evento "fermo", alla risposta <i>movedone/movefailed</i>
    </p>
    <p>
        Per quanto riguarda la <b>posizione</b>, si può ricavare dalle coordinate che il <i>TT</i> invia al <i>TE</i> per implementare il movimento. Infatti, ricordiamo che il <i>TT</i> ha un mapping <i>landmarks-coordinate</i> che gli permette di conoscere la posizione del robot all'interno della stanza. <br>
        Ancora una volta, sarà sufficiente emettere un evento <i>"descrittivo"</i> (HOME, INDOOR, ColdRoom), ogni volta che la posizione del robot cambia. Inoltre, potremo fornire informazioni come "sta andando verso HOME", sapendo appunto le coordinate verso cui lo si sta facendo muovere.
        <p class="keypoint">
            <b>KEY-POINT:</b> in questo modo avremo la <b>posizione puntuale</b> del robot <u>solo quando è fermo</u>. Discutere quindi con il committente questa soluzione.
        </p>
    </p>

    <h5>Posizione del <i>TransportTrolley</i></h5>
    <p>
        Mentre l'informazione sul movimento combacia bene con la <i>moverobot</i>, la stessa cosa non 
    </p>
    <h3>Architettura logica</h3>
    
    <p>
        Si riporta di seguito il modello di architettura logica, limitato al contesto di interesse della <i>ServiceStatusGUI</i>.
    </p>

    <b>TODO: inserire modello tagliato</b>
    <img class="bigimglim" src="../images/sprint4/coldstorageservice23arch.png" alt="Modello architettura logica">

    <p class="keypoint">
        <b>ATTENZIONE:</b> la <i>ServiceStatusGUI</i> NON è stata generata dal progetto <i>qak</i>, per cui va aggiornata manualmente a fronte di eventuali modifiche.
    </p>
</div>


<h2 id="test_plans">Test plans</h2> 

<div class="remark">
    <p>
        Per quanto riguarda i piani di test da implementare, rimanendo ad un <b>livello logico</b>, bisogna effettuare controllare che ogni istanza di <i>SAG</i> riceva le risposte dal <i>CSS</i> solo ed esclusivamente relativamente alla sua sessione. In particolare:
        <ul>
            <li>ad ogni richiesta di deposito deve arrivare la risposta (accettata, rifiutata o un errore)</li>
            <li>in caso di richiesta accettata deve essere essere fornito il <i>ticket code</i></li>
            <li>se il <i>ticket code</i> viene inserito correttamente, deve essere accettato, altrimenti rifiutato</li>
            <li>in caso di ticket accettato, alla richiesta di stato del carico deve arrivare il messaggio <i>chargetaken</i></li>
        </ul>
    </p>
</div>


<h2>Project</h2> 
 
<div class="remark">

    <h3>TicketManager</h3>

    <p>
        L'attore <b>ticketmanager</b> mantiene un'istanza della classe <code class="docutils literal notranslate"><span class="pre">TicketManager</span></code>, questa classe implementa metodi per la generazione di un nuovo ticket e gestisce lo storico dei ticket generati, esponendo metodi per salvare e caricare memoria persistente le informazioni.<br>
    Si riporta di seguito l'UML della classe in questione.
    </p>

    <img class="imglim" src="../images/sprint2/uml_ticketmanager.png" alt="UML ticket manager">

    <p>
        La classe <code class="docutils literal notranslate"><span class="pre">TicketManager</span></code> mantiene i ticket come istanze della data class <code class="docutils literal notranslate"><span class="pre">Ticket</span></code>, si riportano di seguito le specifiche delle propriet&agrave; della classe.
    </p>

    <img class="imglim" src="../images/sprint2/uml_ticket.png" alt="UML ticket manager">

    <h5>Identificazione ticket</h5>

    <p>
        A ogni ticket viene associato un id intero incrementale che lo identifica univocamente, tuttavia questo valore &egrave; a solo uso interno del TicketManager, il sistema tratter&agrave; i ticket tramite la loro rappresentazione, ovvero il codice che viene scambiato con gli utenti del sistema.
    </p>

    <p>
        Per generare i caratteri random che fanno parte della rappresentazione del ticket si fa utilizzo dei metodi offerti dalla classe <code class="docutils literal notranslate"><span class="pre">java.security.SecureRandom</span></code> che garantisce la sicurezza tramite l'utilizzo di uno PRNG.
    </p>
    <pre><code class="language-kotlin">private fun randomString(): String {
    val sr: SecureRandom = SecureRandom.getInstance("SHA1PRNG")
    return sr.ints(STRING_LENGTH, 0, CHAR_POOL.size)
        .asSequence()
        .map(CHAR_POOL::get)
        .joinToString("")
}</code></pre>

    <h5>Gestione tempo di creazione</h5>
    <p>
        A ogni ticket viene associato un timestamp campionato nel momento in cui viene restituito il valore dal metodo che lo genera, viene salvato come valore unix timestamp <code class="docutils literal notranslate"><span class="pre">long</span></code> in millisecondi.
    </p>

    <pre><code class="language-kotlin">val generationTimeMs: Long</code></pre>

    <h3>ColdStorageService</h3>

    <h5>Delega al ticketmanager</h5>

    <p>
        Come specificato in precedenza, il messaggio <i>insertticket</i> pu&ograve; essere inviato a <i>coldstorageservice</i> ma verr&agrave; comunque gestito dal <i>ticketmanager</i>, questa funzionalit&agrave; &egrave; stata implementata utilizzando la keyword <code class="docutils literal notranslate"><span class="pre">delegate</span></code> messa a disposizione dal framework qak.
    </p>
    <p>
        Nello stato iniziale dell'attore <i>coldstorageservice</i> &egrave; riportata la seguente istruzione:
    </p>
    <pre><code class="language-bash">delegate "insertticket" to ticketmanager</code></pre>

    <h5>Associazione ticket-richiesta</h5>

    <p>
        &Egrave; stata implementata l'associazione tra ticket e richiesta utilizzando una <code class="docutils literal notranslate"><span class="pre">MutableMap</span></code>, dichiarata come segue:
        <pre><code class="language-kotlin">val weightTicketMap = mutableMapOf&lt;String, Float&gt;()</code></pre><br>

        Utilizzando questa mappa il ColdStorageService sar&agrave; in grado di comunicare al TransportTrolley il peso relativo alla ticket che sta gestendo, riottenendolo alla risposta del TransportTrolley  per finalizzare il deposito aggiungendo il valore alla variabile <code class="docutils literal notranslate"><span class="pre">actualCurrentColdRoom</span></code>, che mantiene il valore del peso di cibo effettivamente contenuto nella ColdRoom.
        <pre><code class="language-kotlin">val FW = payloadArg(0).toFloat()    
actualCurrentColdRoom += FW</code></pre>
    </p>

    <h3>ServiceAccessGUI</h3>

    <p>
        Abbiamo già parlato e analizzato buona parte della <i>SAG</i> nello <a href="../Sprint1/ServiceAccessGUISimProjectV1.html">Sprint precedente</a>. <br> 
        E' stato anche introdotto il protocollo <b>Coap</b>, utilizzato per le interazioni tra la <i>SAG</i> e il servizio <i>ColdStorageService</i>. Relativamente a ciò, riportiamo nel <i>key-point</i> seguente un fatto fondamentale:
    </p>
    <p class="keypoint">
        <b>KEY-POINT:</b> gli attori <i>qak</i> sono risorse <b>CoapObservable</b>, overro risorse osservabilei tramite la classe CoapObserver definita nella libreria <code class="docutils literal notranslate"><span class="pre">unibo.basicomm23</span></code>.
    </p>

    <h5>Ricezione evento di aggiornamento ColdRoom</h5>
    <p>
        Essendo che la <i>SAG</i>, progetto in Spring, non appartiene al mondo di attori qak, non supporta direttamente la ricezione di un <i>event</i> da parte dell'attore qak <i>coldstorageservice</i>. <br>
        Possiamo però ovviare al problema grazie alla primitiva <b>updateResuource</b>, disponibile in qak. Questa ha lo scopo di inviare un "event" a tutte quelle risorse che stanno osservando l'attore <i>qak</i> di interesse. <br>
    </p>
    <p>
        Lato applicazione Spring, entra quindi in gioco la nuova entità <i>CoapObserver</i>, che ha lo scopo di porsi come osservatore dell'attore <i>coldstorageservice</i>. Sono necessarie inoltre le <i>WebSocket</i> per far giungere l'informazione dall'oggetto java alla pagina html di presentazione.
    </p>
    <p>
        Di seguito, viene riportato il nuovo diagramma UML delle classi del progetto <i>Spring</i>.
    </p>

    <img class="bigimglim" src="../images/sprint2/saguml.png"></img>

    <p>
        Vediamo esserci il nuovo componente <b>CoapObserver</b>: osservatore che, ad ogni aggiornamento emesso dal ColdStorageService, avvisa tutte le entità registrate ad esso tramite <i>WebSocket</i>.
        <p>
            Per l'aggiornamento automatico della pagina da parte del server utilizziamo le <b>WebSocket</b>. Abbiamo infatti un file <a href="../../projects/unibo.serviceaccessGUI/src/main/resources/static/js/ws_utils.js">ws_utils.js</a> che definisce la connessione e gestisce i messaggi in arrivo in maniera opportuna. <br>
            <ul>
                <li><b>WebSocketConfiguration</b>: implementa la classe <i>WebSocketConfigurer</i> di <code class="docutils literal notranslate"><span class="pre">org.springframework.web.socket.config.annotation</span></code>.</li>
                <li><b>WebSocketHandler</b>: memorizza le sessioni registrate e alle quali inviare i messaggi.</li>
            </ul>
        </p>
    </p>

    <h5>Visualizzazione del ticket</h5>
    <p>
        Abbiamo parlato in analisi del problema di fornire il codice all'utente in maniera esterna all'applicazione. <br>
        Pensando in termini di portabilità e semplicità d'uso, abbiamo optato per la generazione di un file <b>pdf</b>, contenente il ticket. <br>
        La scelta è stata mossa dal fatto che un file pdf è leggibile facilmente su tutti i dispositivi (smartphone, pc, tablet, ...) senza l'ausilio di applicazione esterne o non pre-installate. Inoltre, è facilmente scaricabile dalla pagina web.  
    </p>
    <p class="keypoint">
        <b>KEY-POINT:</b> portabilità e semplicità d'uso tramite un file <i>.pdf</i> contente il ticket code.
    </p>

    <p>
        Qui il server risponde alla richiesta all'endpoint <code class="docutils literal notranslate"><span class="pre">/generatePdf</span></code> con il contenuto di un file pdf, questo contenuto binario &egrave; convertito in un <code class="docutils literal notranslate"><span class="pre">Blob</span></code> per poi essere salvato come pdf, a questo scopo si fa utilizzo della libreria <code class="docutils literal notranslate"><span class="pre">FileSaver.js</span></code>
    </p>

    <pre><code class="language-javascript">function generatePdf(inputValue) {

    //data structure to send to server
    const requestBodyMap = {
        ticketCode: inputValue
    }

    //request to server
    const relativeEndpoint = '/generatePdf';
    fetch(
        relativeEndpoint,
        {
            method: 'POST',
            headers: {
                'Accept': 'application/pdf',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBodyMap)
        }
    ).then(response => {
        return response.arrayBuffer();
    }).then(data => {
        var blob = new Blob([data], {type: 'application/pdf'});
        saveAs(blob, 'ticket.pdf');
    }).catch(error => {
            console.log(error);
    });
}</code></pre>

    <h5>Front-end</h5>
    <p>
        Strettamente correlato alla sezione precedente, mostriamo la nuova grafica della <i>ServiceAccessGUI</i>. <br>

    </p>
    
    <img class="imglim" src="../images/sprint2/sag_view.png"></img>

    <p>

        Vediamo esserci il nuovo campo per l'inserimento del ticket. L'idea è che questo campo sia sempre disponibile all'interno della pagina, anche senza che la richiesta di deposito sia stata inviata. <br>
        In questo modo, diamo sempre la possibilità all'utente di inserire il ticket e questo si concilia perfettamente con il concetto della risorsa esterna contenente il ticket, come già spiegato in <a href="#pdf_analisi_prob">analisi del problema</a>.
    </p>
</div>


<h2>Testing</h2> 
 
<div class="remark">
    I test pianificati nella <a href="#test_plans">sezione precedente</a> sono stati implementati tramite un'unità di test <a href="../../projects/sprint2V0/JTestSprint2v0.java" target="_blank" rel="noopener noreferrer">JUnit</a> all'interno del progetto <i>qak</i>.
</div>


<h2>Deployment</h2> 

<div class="remark">
    <p>
    Per il Deployment si fa riferimento alla sezione dello <a href="../Sprint1/ColdStorageServiceSprint1V1.html#deployment" target="_blank" rel="noopener noreferrer">Sprint1</a>. <br>
    
    Una più attenta analisi verrà rimandata in un documento successivo.
    </p> 
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
    GIT repo: https://github.com/RiccardBarbieri/ColdStorageService
    <p>Riccardo Barbieri - riccardo.barbieri11@studio.unibo.it</p>
    <img src="../images/foto/riccardo.jpg" width="15%" height="15%">
    <p>Leonardo Ruberto - leonardo.ruberto@studio.unibo.it</p>
    <img src="../images/foto/leonardo.jpg" width="15%" height="15%">
    </div>
</body>
</html>
