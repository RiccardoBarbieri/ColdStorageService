<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<link rel="stylesheet" href="../_static/template.css">
<link rel="stylesheet" href="../_static/mine.css">
<link rel="stylesheet" href="../_static/code.css">
<link rel="stylesheet" href="../_static/colors.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>


    
<head>
   <title>Sprint1</title>
</head>
    
<body>

<div id="top">

    <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font> </h1>

</div>  

<div class="body"> 

<h2>Introduction</h2>
<div class="remark">
    <p>
        All'interno di questo <i>Sprint</i> verrà analizzato il <b>core-business</b> dell'applicazione, esplicitato nello <a href=".\ColdStorageServiceSprint0V1.html#suddivisioneSprint">Sprint0</a> come l'interazione tra <i>ColdStorageService</i> (CSS) e <i>TransportTrolley</i> (TT).
    </p>
</div>

<h2>Requirements</h2>
 
<div class="remark">
    <a target="_blank" href="https://iss.riccardohost.space/TemaFinale23.html">Descrizione requirements a questa pagina</a><br>

    <p>
    <bc>Goals dello sprint 1</bc>:
    <ol>
        <li>Definire con precisione i componenti dell'applicazione, limitandosi al contesto di <i>ColdStorageService</i> e <i>TransportTrolley</i></li>
        <li>Formulare il modello di interazione tra <b>ColdStorageService</b> e <b>TransportTrolley</b></li>
    </ol>
    </p>
</div>

<h2>Requirement analysis</h2>

<div class="remark">
    <p>
        Dal documento dei requisiti, relativamente a questo <i>Sprint</i>, consideriamo i seguenti argomenti da trattare:
        <ul>
            <li>Service area</li>
            <li>DDR robot e TransportTrolley</li>
            <li>Interazione tra il <i>CSS</i> ed il <i>TT</i></li>
        </ul>
    </p>

    <h3>Entit&agrave;</h3>
    <table>
        <tr>
            <th>Entit&agrave;</th>
            <th>Comportamento</th>
        </tr>
        <tr>
            <td class="green bold center">coldstorageservice</td>
            <td>Gestisce le richieste di deposito e comanda il transport trolley con istruzioni di alto livello, mantiene la rappresentazione della service area</td>
        </tr>
        <tr>
            <td class="green bold center">transporttrolley</td>
            <td>Gestisce le richieste del ColdStorageService inviando comandi di basso livello al basicRobot</td>
        </tr>
        <tr>
            <td class="green bold center">serviceaccessguisim</td>
            <td>Entit&agrave; adibita al testing, l'arrivo di un camion a INDOOR e invia una richiesta a coldstorageservice per dare inizio alla fase di deposito.</td>
        </tr>
        <tr>
            <td class="green bold center">basicrobot</td>
            <td>Entit&agrave; che riceve istruzioni di "medio livello" e le traduce in istruzioni di basso livello per guidare il DDR robot.</td>
        </tr>
    </table>

    <h3 id="dati_analisi_requisiti">Dati</h3>
    <p>
        Di seguito, sono elencati tutti i dati presenti nei requisiti, con annessa una breve descrizione.
        <table>
            <tr>
                <th>Dato</th>
                <th>Tipologia</th>
                <th>Descrizione</th>
            </tr>
            <tr>
                <td class="green bold center">MAXW</td>
                <td>Costante, float</td>
                <td>Limite massimo di chilogrammi che la ColdRoom pu&ograve; contenere in un dato momento.</td>
            </tr>
            <tr>
                <td class="green bold center">RD</td>
                <td>Costante, intera</td>
                <td>Lunghezza del lato del transport trolley.</td>
            </tr>
            <tr>
                <td class="green bold center">FW</td>
                <td>Variabile, float</td>
                <td>Quantit&agrave; di carico che un camion refrigerato deve depositare, espressa in chilogrammi.</td>
            </tr>
            <tr>
                <td class="green bold center">TTState</td>
                <td>Enumerativo</td>
                <td>Tre valori che rappresentano i possibili stati in cui si pu&agrave; trovare il transport trolley (in HOME, in movimento e fermo): <pre>HOME, MOVING, STOPPED</pre></td>
            </tr>
            <tr>
                <td class="green bold center">currentTTState</td>
                <td>Variabile, enumerativo</td>
                <td>Stato attuale del transport trolley, di tipo <code class="prettyprint">TTState</code></td>
            </tr>
        </table>
    </p>

    <h3>Messaggi</h3>

    <table>
        <tr>
            <th>Mittente</th>
            <th>Destinatario</th>
            <th>Tipologia messaggio</th>
            <th>Formato</th>
            <th>Significato</th>
        </tr>
        <tr>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="orange bold center">coldstorageservice</td>
            <td class="blue bold center">Request</td>
            <td>storerequest(FW)</td>
            <td>Richiesta di <b>storage</b> di <b>FW</b> chili di cibo.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Reply</td>
            <td>storeaccept()</td>
            <td>La richiesta di deposito &egrave; stata accettata.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Reply</td>
            <td>storereject()</td>
            <td>La richiesta &egrave; stata rifiutata.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargetaken()</td>
            <td>Il transport trolley ha comunicato di aver prelevato il carico, il camion deve spostarsi da INDOOR.</td>
        </tr>
        <tr>
            <td class="orange bold center">transporttrolley</td>
            <td class="orange bold center">coldstorageservice</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargetakentt()</td>
            <td>Il carico &egrave; stato prelevato dal transport trolley.</td>
        </tr>
    </table>

    <p>
        Dopo un incontro con il committente, che comunica di non avere preferenze a riguardo, abbiamo deciso di proseguire l'analisi basandoci sul secondo modello proposto nel <a target="_blank" href="../Sprint0/ColdStorageServiceSprint0V1.html#modello_requisiti">modello dei requisiti</a> delineato nello <i>Sprint0</i>: il messaggio <b>charge taken</b> sar&agrave; quindi modellato con semantica <b>dispatch</b>.
    </p>
    <p>
        Vediamo che l'unico messaggio che viene inviato dalla <i>ServiceAccessGUISim</i> corrisponde alla richiesta di deposito (<i>storerequest(FW)</i>). Questa decisione si basa sul fatto che in questo <i>Sprint</i> non verrrà trattata la questione dei <b>ticket</b> (fuori dalla core-business logic); perciò avremo che, a seguito di un'eventuale accettazione della richiesta di deposito (<i>storeaccept()</i>), si passerà direttamente alla logica applicativa che la implementa.
    </p>
    <h3>Componenti</h3>

    <h4>ServiceAccessGUISim</h4>

    <p>
        Come detto, in questo Sprint concentreremo l'attenzione sui componenti che implementano la core business logic del sistema e, nonostante non ne faccia direttamente parte, avremo necessità di definire la ServiceAccessGUI per <b>testare</b> il funzionamento della logica applicativa. Ecco perchè, come anticipato nello <a target="_blank" href="../Sprint0/ColdStorageServiceSprint0V1.html#test_plans">Sprint0</a>, verr&agrave; modellata come un <b>simulatore</b> che invia una <i>storerequest</i> al ColdStorageService. <br>
        L'analisi approfondita di questo componente sarà considerata negli sprint successivi.
    </p>


    <h4>TransportTrolley e DDRRobot</h4>
    <p>      
        Il <i>TT</i> &egrave; una entit&agrave; astratta che aggiunge funzionalit&agrave; di pi&ugrave; alto livello ad un DDR robot (come riportato dai requisiti). Queste funzionalit&agrave; sono:
        <ul>
            <li>trasportare un carico di cibo da INDOOR a ColdRoom;</li>
            <li>recarsi in HOME quando non sono presenti richieste;</li>
            <li>comunicare il proprio <b>stato</b> a entit&agrave; interessate.</li>
            <li>comunicare all'utente <i>Camion refrigerato</i> che &egrave; stato prelevato il carico</li>
        </ul><br>

        Queste funzionalit&agrave; condividono un requisito fondamentale: la possibilit&agrave; di navigare la service area. Sar&agrave; quindi necessario crearne una rappresentazione comprensibile al componente che controller&agrave; il robot concreto. Nei successivi paragrafi verrà affrontato questo aspetto.<br>

    </p>
    <p>
        In questa fase dello sviluppo il DDR Robot sar&agrave; rappresentato da un robot virtuale, disponibile alla nostra software house, che offre una visualizzazione di un robot virtuale che naviga una service area (anch'essa virtuale) e gestisce gli stessi comandi di "medio livello" che il DDR Robot &egrave; in grado di gestire.
    </p>


    <h4 id="components_CSS">ColdStorageService</h4>

    <p>
        &Egrave; stata discussa con il committente la questione dell'allontanamento del camion refrigerato dalla INDOOR: il messaggio <b>chargetaken</b> conferma il completamento del ritiro del carico da parte del transport trolley, in tal momento il camion <b>deve allontanarsi immediatamente</b>. In caso di richiesta rifiutata il camion si deve allontanare alla ricezione del messaggio <b>storerejected</b>.
    </p>

    <p>
        Dall'ultimo incontro con il committente &egrave; emerso che il DDR Robot impiega un <b>tempo predefinito</b> per prelevare un carico dal camion.
    </p>
    <h5>Service area</h5>
    <p>
        Dall'analisi dei requisiti dello sprint precedente abbiamo modellato la service area come un rettangolo contenente aree di interesse:
        <ul>
            <li><span class="bold" style="color:rgb(255,0,0);">HOME</span>: quadrato di lato <b>RD</b> che identifica la posizione di partenza del transport trolley, &egrave; collocato sopra alla zona evidenziata;</li>
            <li><span class="bold" style="color:rgb(64,64,228);">ColdRoom</span>: area di dimensione non non ancora definita, rappresenta la ColdRoom dove il transport trolley deve depositrare i carichi;</li>
            <li><span class="bold" style="color:rgb(43,169,43);">INDOOR</span>: posizione lungo la parete inferiore adiacente alla parete sinistra, il transport trolley deve recarsi in quest'area per prelevare i carichi da i camion;</li>
            <li><span class="stroke" style="color:rgb(255,228,0);">PORT</span>: posizione lungo il bordo inferiore dell'area della ColdRoom, il transport trolley deve posizionarsi in questa area per scaricare i carichi nella ColdRoom</li>
        </ul>
    <img class="bigimglim" src="../images/servicearea.png" alt="Modello service area">
    </p>

</div>

<h2>Problem analysis</h2>

<div class="remark">

    <h3>Componenti</h3>

    <h4>ServiceAccessGUISim</h4>

    <p>
        Dobbiamo realizzare un componente software che permetta di simulare molteplici richieste di deposito presso il <i>CSS</i>. In particolare, avremo bisogno di un'applicativo che ci permetta di:
        <ol>
            <li>
                effettuare una <i>richiesta di deposito</i> verso il <i>CSS</i>, specificando la quantità di chilogrammi di cibo <b>FW</b> 
            </li>
            <li>
                visualizzare la risposta relativa alla richiesta appena effettuata (<i>accettata</i> o <i>rifiutata</i>)
            </li>
            <li>solo in caso di <b>richiesta accettata</b>, visualizzare il messaggio di <i>presa in carico</i></li>
        </ol>
        Questi tre passaggi rappresentano il flusso di attività che vogliamo vengano simulate. Alla fine di questi step si realizza l'uscita dalla <i>INDOOR</i> da parte del <i>Camion</i>, aggiornando la vista dell'applicazione per permettere una nuova interazione (da zero). <br>
        Come anticipato precedentemente nella sezione <a href="#components_CSS" target="_blank">componenti</a>, il Camion si deve allontanare anche in caso di <b>richiesta rifiutata</b>, quindi anche in questo casò si dovrà aggiornare la vista dell'applicazione per permettere una nuova interazione. <br>
    </p>
    <p>Per quanto riguarda le <b>tecnologie</b> d'implementazione, pensiamo che un applicazione web sia l'ideale per realizzare questo componente software, per via della sua comodità d'uso e per la possibilità di passare ad un contesto distribuito in modo molto semplice.</p>

    <h4>ColdStorageService</h4>
    <p>
        Il <i>CSS</i> si occupa solo di:
        <ul>
            <li>accettare/rifiutare la richiesta di deposito</li>
            <li>notificare il <i>TransportTrolley</i> della presenza di un nuovo carico</li>
            <li>notificare la <i>ServiceAccessGUISim</i> della presa in carico da parte del <i>TT</i> (messaggio <b>chargetaken</b>)</li>
        </ul>
        Il <i>ColdStorageService</i> non si interessa del raggiungimento dei particolari landmark nella Service Area (<i>HOME</i>,
        <i>INDOOR</i>, <i>ColdRoom</i>), in quanto l'operazione è delegata al <i>TransportTrolley</i>. In questo modo il <i>CSS</i> risulterà completamente indipendente dalla particolare disposizione dell'area di servizio (come le possibili diverse posizioni dei punti di interesse e degli ostacoli).

    </p>
    <p>
        Uno dei principali problemi riguarda appunto la rappresentazione dell'area di servizio, che influisce sull'interazione con il robot e su come esso si muove all'interno della stanza.
    </p>

    <h5>Service area</h5>

    <p>
        A seguito di questa analisi approfondita sull'area di servizio, possiamo aggiungere un nuovo dato, oltre a quelli presenti nella <a href="#dati_analisi_requisiti" target="_blank">tabella dei dati</a> sopra riportata.
    </p>
    <table>
        <tr>
            <th>Dato</th>
            <th>Tipologia</th>
            <th>Descrizione</th>
        </tr>
        <tr>
            <td class="green bold center">currentTTPosition</td>
            <td>Variabile, tupla di interi</td>
            <td>Posizione del transport trolley nella service area, in coordinate x e y secondo lo schema del modello della service area.</td>
        </tr>
    </table>

    <p>
        Abbiamo deciso di suddividere la <b>service area</b> in una griglia di quadrati di lato <b>RD</b>: ogni posizione sulla griglia pu&ograve; contenere il DDR robot.
    </p>

    <p>
        La rappresentazione della service area diventa quindi come in figura, si noti il sistema di assi cartesiani che pone il punto (0, 0) in corrispondenza della posizione <b>HOME</b>, che corrisponde alla posizione di partenza.
    </p>

    <p>
        I <i>punti di interesse</i> <b>INDOOR</b> e <b>PORT</b> finora sono stati modellati come posizioni monodimensionali, in quanto si tratta di "aperture" al quale il robot pu&agrave; accedere, in questo modello verranno indicati come "<i>la posizione in cui il robot deve trovarsi per potervi accedere</i>".
    </p>

    <p>
        Dal punto di vista del <b>transport trolley</b> la service area sar&agrave; rappresentata da una <b>matrice NxM</b>. 
    </p>

    <p>
    <figure>
        <figcaption>Modello service area - non rispecchia le dimensione effettive</figcaption>
        <img class="bigimglim" src="../images/serviceareagridaxes.png" alt="Modello service area">
    </figure>
    </p>

    <p>
        Per generare una mappa della service area abbiamo sfruttato il software <code class="prettyprint">unibo.mapperQak23</code> che si avvale di <code class="prettyprint">basicrobot</code> per esplorare ottenere la dimensione dell'area e individuare eventuali ostacoli lungo i bordi, generando una rappresentazione della service area.
    </p>

    <h5>Utilizzo del mapper</h5>

    Per utilizzare il mapper per generare la matrice che rappresenta la service area, senza considerare gli ostacoli:

    <ol>
        <li>
            Avviare WEnv, l'ambiente virtuale che simula il DDR robot:
            <pre>docker compose -f projects/it.unibo.virtualRobot2023/virtualRobot23.yaml up</pre>
        </li>
        <li>
            Avviare basicrobot:
            <pre>projects/unibo.basicrobot23/gradlew run</pre>
        </li>
        <li>
            Avviare il mapper:
            <pre>projects/unibo.mapperQak23/gradlew run</pre>
        </li>
        
    </ol>

    Il mapper produce:

    <ol>
        <li>Un <a href="">file testuale</a> contenente una rappresentazione della mappa.<pre>|r, 1, 1, 1, 1, 1, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 1, 1, 1, 1, 1, 1,</pre></li>
        <li>Un <a>file binario</a> contenente una istanza della classe <code class="prettyprint">unibo.planner23.model.RoomMap</code>, utilizzabile in coppia con una istanza della classe <code class="prettyprint">unibo.planner23.Planner23Util</code></li>
    </ol>
    
    <h5>Configurazione landmark</h5>

    <p>
        Per permettere a un utente di configurare la posizione dei landmark di interesse nella service area verr&agrave; messo a disposizione un applicativo che espone una interfaccia grafica per posizionare i punti di interesse in una <b>griglia</b>.
    </p>

    <p>
        Questo applicativo generer&agrave; rappresentazioni testuali e un file binario utilizzabile dal planner per creare i percorsi di movimento del transport trolley.
    </p>

    <p>
        Di seguito &egrave; riportato un esempio del contenuto del file di testo che verr&agrave; generato dall'applicativo. Questo file in particolare non sar&agrave; utilizzato da nessun componente del sistema, ma rappresenta la configurazione creata dall'utente.
    </p>

        <pre>|<span class="bold homecolor">H</span>, 1, 1, 1, 1, 1, 1,
|1, 0, 0, 0, <span class="bold coldcolor">C</span>, <span class="bold coldcolor">C</span>, 1,
|1, 0, 0, 0, <span class="bold coldcolor">C</span>, <span class="bold coldcolor">C</span>, 1,
|1, 0, 0, 0, <span class="bold stroke portcolor">P</span>, <span class="bold stroke portcolor">P</span>, 1,
|<span class="bold indoorcolor">I</span>, <span class="bold indoorcolor">I</span>, <span class="bold indoorcolor">I</span>, 1, 1, 1, 1,</pre>
    </p>

    <h4>TransportTrolley & DDR Robot</h4>

    <b>DA METTERE A POSTO</b> <br>
    <br>
    L'analisi di questa problematica si rimanda a sprint successivi, abbiamo per&ograve; individuato una serie di componenti che saranno necessari:
    <ul>
        <li><b>transport trolley</b> come astrazione di DDR robot;</li>
        <li><b>mapper</b> per creare la rappresentazione della service area;</li>
        <li><b>planner</b> per decidere il percorso (ottimale o meno) per raggiungere un punto nella rappresentazione della service area;</li>
        <li><b>controller</b> che invia istruzioni di movimento comprensibili dal DDR robot;</li>
        <li>DDR robot concreto, fornito dal committente.</li>
    </ul>

    Queste funzionalit&agrave; sono implementate dal software fornito dal cliente <code class="prettyprint">basicrobot</code>: esso permette di muovere un robot generico (DDR robot, robot virtuale) seguendo percorsi preparati (non necessariamente ottimali) per spostarsi nella service area.<br>

    <h5>Basic robot</h5>

    <h3>Interazioni</h3>

    Inserire tabella interazioni presente in Sprint0v0 (togliendo la parte col raspberry). <br>
    Rifare i diagrammi di sequenza.

    <h3>Architettura logica</h3>
    Trafiletto su contesti e attori prima dell'immagine dell'architettura.
</div>


<h2>Test plans</h2> 

<div class="remark">
    
</div>


<h2>Project</h2> 
 
<div class="remark">

    <h3>ServiceAccessGUISim</h3>
    <p>
        Come anticipato in fase di analisi del problema, si è pensato di implementare questo componente software come un'applicazione Web. <br>
        In particolare, abbiamo optato per l'utilizzo del framework <b>Spring</b>. 
    </p>
    <h4>Architettura dell'applicazione</h4>
    <p>
        Nell'immagine seguente viene mostrata la struttura del back-end dell'applicazione Web. 
    </p>
    <img class="bigimglim" src="../images/architettura_logica_SAGSim.png" alt="Architettura logica Service Access Gui Simulata, realizzata in Spring">
    <p>
        Prendiamo in analisi i singoli componenti:
        <ul>
            <li><b>SagController</b>: controller dell'applicazione definito tramite annotazione del framework <i>Spring</i>. Si occupa di inizializzare l'applicazione definendo un osservatore sull'attore interessato; funge poi da mediatore tra UI e back-end per l'invio al ColdStorageService della richiesta di deposito.</li>
            <li><b>SagConnection</b>: componente dell'applicazione che si occupa di stabilire una connessione Coap con l'attore interessato nel progetto <i>ColdStorageService</i> e di implementare la comunicazione con l'attore stesso relativamente alla richiesta di deposito.</li>
            <li><b>ConnectionUtils</b>: definisce una nuova <i>CoapConnection</i>.</li>
            <li><b>CoapObserver</b>: osservatore che, ad ogni aggiornamento emesso dal ColdStorageService, avvisa tutte le entità registrate ad esso tramite <i>WebSocket</i></li>
            <li><b>WebSocketConfiguration</b>: </li>
            <li><b>WebSocketHandler</b>: </li>
        </ul>
        <p>
            <b>AGGIUNGERE PARTE SU SPRING PRESA DA SPRINGBOOTINTRO.HTML</b>
        </p>
    </p>
    <h5>Comunicazione con il ColdStorageService</h5>
    <h5>Configurazione</h5>
    <p>L'applicazione può essere configurata interamente dal file <b>application.properties</b>.</p>
    <img class="bigimglim" src="../images/application_properties.png" alt="File di configurazione application.properties">
    <p>
        Oltre a poter configurare il nome dell'applicazione che apparirà in alto nella pagina web e il banner da mostrare in console, sono presenti:
        <ul>
            <li>server.port, per configurare la porta sulla quale apparirà la pagina web</li>
            <li>actor.name, per definire il nome dell'attore da osservare e al quale verrà inviata la richiesta di deposito</li>
            <li>actor.ctx.*, per specificare tutte le informazioni relative al contesto in cui è presente l'attore d'interesse</li>
        </ul>
    </p>
    <h4>Front-end</h4>
    <img class="bigimglim" src="../images/frontend_SAGSim.png" alt="Frontend Service Access Gui Simulata">
    <p>
        L'applicazione permette di inserire una quantità numerica che rappresenta i kg di carico da depositare e, previa validazione dell'input con eventuale toast di errore, invia la richiesta al CSS. <br>
        A questo punto possono presentarsi tre casi:
        <ul>
            <li>richiesta accettata: l'utente viene notificato dell'accettazione della richiesta, indicandogli di attendere la presa in carico. 
                <p>
                    In questo contesto, due casi sono possibili:
                <ul>
                    <li>se passa troppo tempo, il messaggio viene dato per perso, avvisando l'utente e ricaricando la pagina</li>
                    <li>arriva il messaggio di presa in carico, che viene mostrato in pagina, per poi ricaricarla</li>
                </ul>
            </li>
                </p>
            <li>richiesta rifiutata: l'utente viene avviso del rifiuto e la pagina web si ricarica, permettendo una nuova interazione.</li>
            <li>errore in fase di richiesta: se la richiesta non va a buon fine o passa troppo tempo, l'utente viene notificato e la pagina web si ricarica, permettendo una nuova interazione.</li>
        </ul>
    </p>
    <p>
        <b>AGGIUNGERE PARTE SU BOOTSTRAP E SU JS</b>
    </p>

    <h3>ColdStorageService</h3>
    <p>        <b>Parliamo di come abbiamo implementato il CSS (in pratica il file .qak)</b>
    </p>

    <p>
        <b>CI SONO DEI RAGIONAMENTI DA FARE:
            <ul>
                <li>come memorizziamo lo spazio disponibile? C'è una terza entità che lo fa?</li>
                <li>come scegliamo se accettare o meno la risposta</li>
            </ul>
        </b>
    </p>

    <h3>Applicazione per la mappa di rick</h3>

</div>

<h2>Testing</h2> 
 
<div class="remark">

</div>

<h2>Deployment</h2> 

<div class="remark">

</div>
 
<h2>Maintenance</h2> 
 
<div class="remark">

</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
GIT repo: https://github.com/RiccardBarbieri/ColdStorageService
</div>
</div>
</body>
</html>
