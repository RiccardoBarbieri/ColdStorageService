<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="stylesheet" href="../_static/template.css">
<link rel="stylesheet" href="../_static/mine.css">
<link rel="stylesheet" href="../_static/code.css">
<link rel="stylesheet" href="../_static/colors.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/dockerfile.min.js"></script>


<script>hljs.highlightAll();</script>
<title>Sprint1</title>
</head>
    
<body>

<div id="top">

    <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE<font size="5"></font> </h1>

</div>  

<div class="body"> 

<h2>Introduction</h2>
<div class="remark">
    <p>
        All'interno di questo <i>Sprint</i> verrà analizzato il <b>core-business</b> dell'applicazione, esplicitato nello <a href=".\ColdStorageServiceSprint0V1.html#suddivisioneSprint">Sprint0</a> come l'interazione tra <i>ColdStorageService</i> (CSS) e <i>TransportTrolley</i> (TT).
    </p>
</div>

<h2>Requirements</h2>
 
<div class="remark">
    <a target="_blank" href="https://iss.riccardohost.space/TemaFinale23.html">Descrizione requirements a questa pagina</a><br>

    <p>
    <bc>Goals dello sprint 1</bc>:
    <ol>
        <li>Definire con precisione i componenti dell'applicazione, limitandosi al contesto di <i>ColdStorageService</i> e <i>TransportTrolley</i></li>
        <li>Formulare il modello di interazione tra <b>ColdStorageService</b> e <b>TransportTrolley</b></li>
    </ol>
    </p>
</div>

<h2>Requirement analysis</h2>

<div class="remark">
    <p>
        Dal documento dei requisiti, relativamente a questo <i>Sprint</i>, consideriamo i seguenti argomenti da trattare:
        <ul>
            <li>Service area</li>
            <li>DDR robot e TransportTrolley</li>
            <li>Interazione tra il <i>CSS</i> ed il <i>TT</i></li>
        </ul>
    </p>

    <h3>Entit&agrave;</h3>
    <p>
        
    </p>
    <table>
        <tr>
            <th>Entit&agrave;</th>
            <th>Comportamento</th>
        </tr>
        <tr>
            <td class="green bold center">coldstorageservice</td>
            <td>Gestisce le richieste di deposito e comanda il transport trolley con istruzioni di alto livello, mantiene la rappresentazione della service area</td>
        </tr>
        <tr>
            <td class="green bold center">transporttrolley</td>
            <td>Gestisce le richieste del ColdStorageService inviando comandi di basso livello al basicRobot</td>
        </tr>
        <tr>
            <td class="green bold center">serviceaccessguisim</td>
            <td>Entit&agrave; adibita al testing, l'arrivo di un camion a INDOOR e invia una richiesta a coldstorageservice per dare inizio alla fase di deposito.</td>
        </tr>
        <tr>
            <td class="green bold center">basicrobot</td>
            <td>Entit&agrave; che riceve istruzioni di "medio livello" e le traduce in istruzioni di basso livello per guidare il DDR robot.</td>
        </tr>
    </table>

    <h3 id="dati_analisi_requisiti">Dati</h3>
    <p>
        Di seguito, sono elencati tutti i dati presenti nei requisiti, con annessa una breve descrizione.
    </p>
        <table>
            <tr>
                <th>Dato</th>
                <th>Tipologia</th>
                <th>Descrizione</th>
            </tr>
            <tr>
                <td class="green bold center">MAXW</td>
                <td>Costante, float</td>
                <td>Limite massimo di chilogrammi che la ColdRoom pu&ograve; contenere in un dato momento.</td>
            </tr>
            <tr>
                <td class="green bold center">RD</td>
                <td>Costante, intera</td>
                <td>Lunghezza del lato del transport trolley.</td>
            </tr>
            <tr>
                <td class="green bold center">FW</td>
                <td>Variabile, float</td>
                <td>Quantit&agrave; di carico che un camion refrigerato deve depositare, espressa in chilogrammi.</td>
            </tr>
            <tr>
                <td class="green bold center">TTState</td>
                <td>Enumerativo</td>
                <td>Tre valori che rappresentano i possibili stati in cui si pu&agrave; trovare il transport trolley (in HOME, in movimento e fermo): <pre>HOME, MOVING, STOPPED</pre></td>
            </tr>
            <tr>
                <td class="green bold center">currentTTState</td>
                <td>Variabile, enumerativo</td>
                <td>Stato attuale del transport trolley, di tipo <code class="prettyprint">TTState</code></td>
            </tr>
        </table>

    <h3>Messaggi</h3>
    <p>
        
    </p>

    <table>
        <tr>
            <th>Mittente</th>
            <th>Destinatario</th>
            <th>Tipologia messaggio</th>
            <th>Formato</th>
            <th>Significato</th>
        </tr>
        <tr>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="orange bold center">coldstorageservice</td>
            <td class="blue bold center">Request</td>
            <td>storerequest(FW)</td>
            <td>Richiesta di <b>storage</b> di <b>FW</b> chili di cibo.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Reply</td>
            <td>loadaccept()</td>
            <td>La richiesta di deposito &egrave; stata accettata.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Reply</td>
            <td>loadreject()</td>
            <td>La richiesta &egrave; stata rifiutata.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">serviceaccessguisim</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargetaken()</td>
            <td>Il transport trolley ha comunicato di aver prelevato il carico, il camion deve spostarsi da INDOOR.</td>
        </tr>
        <tr>
            <td class="orange bold center">transporttrolley</td>
            <td class="orange bold center">coldstorageservice</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargetakentt()</td>
            <td>Il carico &egrave; stato prelevato dal transport trolley.</td>
        </tr>
        <tr>
            <td class="orange bold center">transporttrolley</td>
            <td class="orange bold center">coldstorageservice</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargedeposited()</td>
            <td>Il carico &egrave; stato depositato nella ColdRoom.</td>
        </tr>
        <tr>
            <td class="orange bold center">coldstorageservice</td>
            <td class="orange bold center">transporttrolley</td>
            <td class="blue bold center">Dispatch</td>
            <td>deposit()</td>
            <td>Il CSS comunica al TransportTrolley che deve recarsi a INDOOR, prendere il carico e portare alla ColdRoom</td>
        </tr>
    </table>

    <p>
        Dopo un incontro con il committente, che comunica di non avere preferenze a riguardo, abbiamo deciso di proseguire l'analisi basandoci sul secondo modello proposto nel <a target="_blank" href="../Sprint0/ColdStorageServiceSprint0V1.html#modello_requisiti">modello dei requisiti</a> delineato nello <i>Sprint0</i>: il messaggio <b>charge taken</b> sar&agrave; quindi modellato con semantica <b>dispatch</b>.
    </p>
    <p>
        Vediamo che l'unico messaggio che viene inviato dalla <i>ServiceAccessGUISim</i> corrisponde alla richiesta di deposito (<i>storerequest(FW)</i>). Questa decisione si basa sul fatto che in questo <i>Sprint</i> non verrrà trattata la questione dei <b>ticket</b> (fuori dalla core-business logic); perciò avremo che, a seguito di un'eventuale accettazione della richiesta di deposito (<i>storeaccept()</i>), si passerà direttamente alla logica applicativa che la implementa.
    </p>
    <h3>Componenti</h3>

    <h4>ServiceAccessGUISim</h4>

    <p>
        Come detto, in questo Sprint concentreremo l'attenzione sui componenti che implementano la core business logic del sistema e, nonostante non ne faccia direttamente parte, avremo necessità di definire la ServiceAccessGUI per <b>testare</b> il funzionamento della logica applicativa. Ecco perchè, come anticipato nello <a target="_blank" href="../Sprint0/ColdStorageServiceSprint0V1.html#test_plans">Sprint0</a>, verr&agrave; modellata come un <b>simulatore</b> che invia una <i>storerequest</i> al ColdStorageService. <br>
        L'analisi approfondita di questo componente sarà considerata negli sprint successivi.
    </p>


    <h4 id="tt_analisi_requisiti">TransportTrolley e DDRRobot</h4>
    <p>      
        Il <i>TT</i> &egrave; una entit&agrave; astratta che aggiunge funzionalit&agrave; di pi&ugrave; alto livello ad un DDR robot (come riportato dai requisiti). Queste funzionalit&agrave; sono:
        <ul>
            <li>trasportare un carico di cibo da INDOOR a ColdRoom;</li>
            <li>recarsi in HOME quando non sono presenti richieste;</li>
            <li>comunicare il proprio <b>stato</b> a entit&agrave; interessate.</li>
            <li>comunicare all'utente <i>Camion refrigerato</i> che &egrave; stato prelevato il carico</li>
        </ul><br>

        Queste funzionalit&agrave; condividono un requisito fondamentale: la possibilit&agrave; di navigare la service area. Sar&agrave; quindi necessario crearne una rappresentazione comprensibile al componente che controller&agrave; il robot concreto. Nei successivi paragrafi verrà affrontato questo aspetto.<br>

    </p>
    <p>
        In questa fase dello sviluppo il DDR Robot sar&agrave; rappresentato da un robot virtuale, disponibile alla nostra software house, che offre una visualizzazione di un robot virtuale che naviga una service area (anch'essa virtuale) e gestisce gli stessi comandi di "medio livello" che il DDR Robot &egrave; in grado di gestire.
    </p>


    <h4 id="components_CSS">ColdStorageService</h4>

    <p>
        &Egrave; stata discussa con il committente la questione dell'allontanamento del camion refrigerato dalla INDOOR: il messaggio <b>chargetaken</b> conferma il completamento del ritiro del carico da parte del transport trolley, in tal momento il camion <b>deve allontanarsi immediatamente</b>. In caso di richiesta rifiutata il camion si deve allontanare alla ricezione del messaggio <b>storerejected</b>.
    </p>

    <p>
        Dall'ultimo incontro con il committente &egrave; emerso che il DDR Robot impiega un <b>tempo predefinito</b> per prelevare un carico dal camion.
    </p>
    <h5>Service area</h5>
    <p>
        Dall'analisi dei requisiti dello sprint precedente abbiamo modellato la service area come un rettangolo contenente aree di interesse:
        <ul>
            <li><span class="bold" style="color:rgb(255,0,0);">HOME</span>: quadrato di lato <b>RD</b> che identifica la posizione di partenza del transport trolley, &egrave; collocato sopra alla zona evidenziata;</li>
            <li><span class="bold" style="color:rgb(64,64,228);">ColdRoom</span>: area di dimensione non non ancora definita, rappresenta la ColdRoom dove il transport trolley deve depositrare i carichi;</li>
            <li><span class="bold" style="color:rgb(43,169,43);">INDOOR</span>: posizione lungo la parete inferiore adiacente alla parete sinistra, il transport trolley deve recarsi in quest'area per prelevare i carichi da i camion;</li>
            <li><span class="stroke" style="color:rgb(255,228,0);">PORT</span>: posizione lungo il bordo inferiore dell'area della ColdRoom, il transport trolley deve posizionarsi in questa area per scaricare i carichi nella ColdRoom</li>
        </ul>
    <img class="bigimglim" src="../images/sprint1/servicearea.png" alt="Modello service area">
    </p>

</div>

<h2>Problem analysis</h2>

<div class="remark">

    <h3>Componenti</h3>

    <h4>ServiceAccessGUISim</h4>

    <p>
        Dobbiamo realizzare un componente software che permetta di simulare molteplici richieste di deposito presso il <i>CSS</i>. In particolare, avremo bisogno di un'applicativo che ci permetta di:
        <ol>
            <li>
                effettuare una <i>richiesta di deposito</i> verso il <i>CSS</i>, specificando la quantità di chilogrammi di cibo <b>FW</b> 
            </li>
            <li>
                visualizzare la risposta relativa alla richiesta appena effettuata (<i>accettata</i> o <i>rifiutata</i>)
            </li>
            <li>solo in caso di <b>richiesta accettata</b>, visualizzare il messaggio di <i>presa in carico</i></li>
        </ol>
        Questi tre passaggi rappresentano il flusso di attività che vogliamo vengano simulate. Alla fine di questi step si realizza l'uscita dalla <i>INDOOR</i> da parte del <i>Camion</i>, aggiornando la vista dell'applicazione per permettere una nuova interazione (da zero). <br>
        Come anticipato precedentemente nella sezione <a href="#components_CSS" target="_blank">componenti</a>, il Camion si deve allontanare anche in caso di <b>richiesta rifiutata</b>, quindi anche in questo casò si dovrà aggiornare la vista dell'applicazione per permettere una nuova interazione. <br>
    </p>
    <p>Per quanto riguarda le <b>tecnologie</b> d'implementazione, pensiamo che un applicazione web sia l'ideale per realizzare questo componente software, per via della sua comodità d'uso e per la possibilità di passare ad un contesto distribuito in modo molto semplice.</p>

    <h4>ColdStorageService</h4>
    <p>
        Il <i>CSS</i> si occupa solo di:
        <ul>
            <li>accettare/rifiutare la richiesta di deposito</li>
            <li>notificare il <i>TransportTrolley</i> della presenza di un nuovo carico</li>
            <li>notificare la <i>ServiceAccessGUISim</i> della presa in carico da parte del <i>TT</i> (messaggio <b>chargetaken</b>)</li>
        </ul>
        Il <i>ColdStorageService</i> non si interessa del raggiungimento dei particolari landmark nella Service Area (<i>HOME</i>,
        <i>INDOOR</i>, <i>ColdRoom</i>), in quanto l'operazione è delegata al <i>TransportTrolley</i>. In questo modo il <i>CSS</i> risulterà completamente indipendente dalla particolare disposizione dell'area di servizio (come le possibili diverse posizioni dei punti di interesse e degli ostacoli).

    </p>
    <p>
        Uno dei principali problemi riguarda appunto la rappresentazione dell'area di servizio, che influisce sull'interazione con il robot e su come esso si muove all'interno della stanza.
    </p>

    <h5 id="servicearea_analisi_problema">Service area</h5>

    <p>
        A seguito di questa analisi approfondita sull'area di servizio, possiamo aggiungere un nuovo dato, oltre a quelli presenti nella <a href="#dati_analisi_requisiti" target="_blank">tabella dei dati</a> sopra riportata.
    </p>
    <table>
        <tr>
            <th>Dato</th>
            <th>Tipologia</th>
            <th>Descrizione</th>
        </tr>
        <tr>
            <td class="green bold center">currentTTPosition</td>
            <td>Variabile, tupla di interi</td>
            <td>Posizione del transport trolley nella service area, in coordinate x e y secondo lo schema del modello della service area.</td>
        </tr>
    </table>

    <p>
        Abbiamo deciso di suddividere la <b>service area</b> in una griglia di quadrati di lato <b>RD</b>: ogni posizione sulla griglia pu&ograve; contenere il DDR robot.
    </p>

    <p>
        La rappresentazione della service area diventa quindi come in figura, si noti il sistema di assi cartesiani che pone il punto (0, 0) in corrispondenza della posizione <b>HOME</b>, che corrisponde alla posizione di partenza.
    </p>

    <p>
        I <i>punti di interesse</i> <b>INDOOR</b> e <b>PORT</b> finora sono stati modellati come posizioni monodimensionali, in quanto si tratta di "aperture" al quale il robot pu&agrave; accedere, in questo modello verranno indicati come "<i>la posizione in cui il robot deve trovarsi per potervi accedere</i>".
    </p>

    <p>
        Dal punto di vista del <b>transport trolley</b> la service area sar&agrave; rappresentata da una <b>matrice NxM</b>. 
    </p>

    <p>
    <figure>
        <figcaption>Modello service area - non rispecchia le dimensione effettive</figcaption>
        <img class="bigimglim" src="../images/sprint1/serviceareagridaxes.png" alt="Modello service area">
    </figure>
    </p>

    <p>
        Per generare una mappa della service area abbiamo sfruttato il software <code class="prettyprint">unibo.mapperQak23</code> che si avvale di <code class="prettyprint">basicrobot</code> per esplorare ottenere la dimensione dell'area e individuare eventuali ostacoli lungo i bordi, generando una rappresentazione della service area.
    </p>

    <h5>Utilizzo del mapper</h5>

    Per utilizzare il mapper per generare la matrice che rappresenta la service area, senza considerare gli ostacoli:

    <ol>
        <li>
            Avviare WEnv, l'ambiente virtuale che simula il DDR robot:
            <pre>docker compose -f projects/it.unibo.virtualRobot2023/virtualRobot23.yaml up</pre>
        </li>
        <li>
            Avviare basicrobot:
            <pre>projects/unibo.basicrobot23/gradlew run</pre>
        </li>
        <li>
            Avviare il mapper:
            <pre>projects/unibo.mapperQak23/gradlew run</pre>
        </li>
        
    </ol>

    Il mapper produce:

    <ol>
        <li>Un <a href="">file testuale</a> contenente una rappresentazione della mappa.<pre>|r, 1, 1, 1, 1, 1, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 0, 0, 0, 0, 0, 1,
|1, 1, 1, 1, 1, 1, 1,</pre></li>
        <li>Un <a>file binario</a> contenente una istanza della classe <code class="prettyprint">unibo.planner23.model.RoomMap</code>, utilizzabile in coppia con una istanza della classe <code class="prettyprint">unibo.planner23.Planner23Util</code></li>
    </ol>
    
    <h5>Configurazione landmark</h5>

    <p>
        Per permettere a un utente di configurare la posizione dei landmark di interesse nella service area verr&agrave; messo a disposizione un applicativo che espone una interfaccia grafica per posizionare i punti di interesse in una <b>griglia</b>.
    </p>

    <p>
        Questo applicativo generer&agrave; rappresentazioni testuali e un file binario utilizzabile dal planner per creare i percorsi di movimento del transport trolley.
    </p>

    <p>
        Di seguito &egrave; riportato un esempio del contenuto del file di testo che verr&agrave; generato dall'applicativo. Questo file in particolare non sar&agrave; utilizzato da nessun componente del sistema, ma rappresenta la configurazione creata dall'utente.
    </p>

        <pre>|<span class="bold homecolor">H</span>, 1, 1, 1, 1, 1, 1,
|1, 0, 0, 0, <span class="bold coldcolor">C</span>, <span class="bold coldcolor">C</span>, 1,
|1, 0, 0, 0, <span class="bold coldcolor">C</span>, <span class="bold coldcolor">C</span>, 1,
|1, 0, 0, 0, <span class="bold stroke portcolor">P</span>, <span class="bold stroke portcolor">P</span>, 1,
|<span class="bold indoorcolor">I</span>, <span class="bold indoorcolor">I</span>, <span class="bold indoorcolor">I</span>, 1, 1, 1, 1,</pre>
    </p>
    
    <p>
        In questo sprint verr&agrave; implementato un simulatore si ServiceAccessGUI che non gestir&agrave; l'inserimento del ticket, questa funzionalit&agrave; verr&agrave; analizzata nel prossimo sprint, tuttavia verr&agrave; implementata una versione del ColdStorageService in grado di gestire richieste di deposito concorrenti.
    </p>

    <h4>TransportTrolley & DDR Robot</h4>

    <p>
        Il <b>DDR Robot</b> è il punto finale della catena di core-business, l'entità che esegue le azioni di deposito. Possiamo quindi pensarlo come il vero "robot", che potrebbe essere reale o virtuale. <br> 
        D'altra parte, il <b>Transport Trolley</b> è un concetto più astratto, che racchiude la logica e controlla il Robot DDR.
    </p>
    <p>
        All'interno del <i>ColdStorageService</i> opererà quindi l'entità <i>TransportTrolley</i>, occupandosi di tutte le funzionalità descritte in fase di <a href="#tt_analisi_requisiti">analisi dei requisiti</a>. Questa entità astratta dovrà comunicare con il "vero" robot per implementare il movimento e le azioni da compiere. <br>
        Entra quindi in gioco l'attore QAK BasicRobot, fornito dal committente all'interno del progetto <code class="prettyprint">unibo.basicroboot23</code>. In questo modo, otteniamo anche un <b>ambiente virtuale</b> per simulare il comportamento del <i>DDR Robot</i> (WEnv/VirtualRobot).
    </p>

    <h5 id="basicRobot_analisi">Basic robot</h5>
    <p>
        L'attore QAK BasicRobot, contestualmente alla core-business di questo <i>Sprint</i>, si occuperà di implementare il movimento tra i vari <i>landmarks</i> della <a href="#servicearea_analisi_problema">Service Area</a>. <br>
    Tra le entità da noi definite, il <i>TransportTrolley</i> è l'unico a comunicare con il suddetto attore: necessiterà di tre messaggi per attuare gli spostamenti:
    <ul>
        <li><b>engage(OWNER, STEPTIME)</b>: in fase di inizializzazione, specificando al basicrobot chi lo sta usando (per ottenere l'accesso esclusivo) e qual è lo <i>STEPTIME</i></li>
        <li><b>setpos(X,Y,D)</b>: al successo dell'engage il transportrolley invia questo messaggio al basicrobot per comunicare la posizione e direzione attuali del virtualrobot: il basicrobot manterr&agrave; internamento lo stato del robot basandosi su questa inizializzazione</li>
        <li><b>moverobot(TARGETX, TARGETY)</b>: per realizzare il movimento all'interno della <i>Service Area</i>.</li>
    </ul>
    </p>
    <p>
        <b>Nota</b>  Essendo che il <i>BasicRobot</i> necessità di coordinate per muoversi, il <i>TransportTrolley</i> deve conoscerle obbligatoriamente. In particolare, deve avere a disposizione il mapping <i>landmarks</i>-<i>coordinate</i>.
    </p>

    <h3>Interazioni</h3>

    <p>
        Di seguito, vengono riportare le interazioni presenti tra le componenti d'interesse, che realizzano il core-business dell'applicazione.
    </p>
    <table>
        <tr>
            <th>Mittente</th>
            <th>Destinatario</th>
            <th>Tipologia messaggio</th>
            <th>Formato</th>
            <th>Significato</th>
        </tr>
        <tr>
            <td class="orange bold center">ServiceAccessGUI</td>
            <td class="orange bold center">ColdStorageService</td>
            <td class="blue bold center">Request</td>
            <td>loadrequest(FW)</td>
            <td>Richiesta di <b>storage</b> di <b>FW</b> chili di cibo</td>
        </tr>
        <tr>
            <td class="orange bold center">ColdStorageService</td>
            <td class="orange bold center">ServiceAccessGUI</td>
            <td class="blue bold center">Reply</td>
            <td>loadaccepted</td>
            <td>La richiesta &egrave; stata processata ed accettata</td>
        </tr>
        <tr>
            <td class="orange bold center">ColdStorageService</td>
            <td class="orange bold center">ServiceAccessGUI</td>
            <td class="blue bold center">Reply</td>
            <td>loadrejected</td>
            <td>La richiesta &egrave; stata processata e respinta</td>
        </tr>
        <tr>
            <td class="orange bold center">ColdStorageService</td>
            <td class="orange bold center"> - </td>
            <td class="blue bold center">Event</td>
            <td>chargetaken</td>
            <td>Il carico &egrave; stato prelevato dal transport trolley, il camion pu&ograve; spostarsi da INDOOR</td>
        </tr>
        <tr>
            <td class="orange bold center">ColdStorageService</td>
            <td class="orange bold center">TransportTrolley</td>
            <td class="blue bold center">Dispatch</td>
            <td>deposit(FW)</td>
            <td>E' presente alla INDOOR un nuovo carico da prelevare</td>
        </tr>
        <tr>
            <td class="orange bold center">TransportTrolley</td>
            <td class="orange bold center">ColdStorageService</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargetakentt()</td>
            <td>Il carico presente alla INDOOR &egrave; stato prelevato dal transport trolley</td>
        </tr>
        <tr>
            <td class="orange bold center">TransportTrolley</td>
            <td class="orange bold center">ColdStorageService</td>
            <td class="blue bold center">Dispatch</td>
            <td>chargedeposited(FW)</td>
            <td>Il carico preso dal transport trolley è stato depositato nella ColdRoom</td>
        </tr>
    </table>

    <p>
        A queste, vengono aggiunte le interazioni presenti tra <b>TransportTrolley</b> e <b>DDR Robot</b> per realizzare il movimento vero e proprio (descritte nella sezione <a href="#basicRobot_analisi">Basic robot</a>).
    </p>

    <h5>Diagrammi di sequenza</h5>
    <p>
        Le frecce sono colorate in base al tipo di messaggio:
        <ul>
            <li><span class="bold" style="color:rgb(231, 48, 48);">request/reply</span></li>
            <li><span class="bold" style="color:rgb(48, 79, 231);">dispatch</span></li>
            <li><span class="bold" style="color:rgb(48, 231, 109);">event</span></li>
        </ul>
    </p>
    <p>
        Si riporta lo schema di funzionamento del core-business, supponendo che il carico venga accettato (in caso contrario il flusso si ferma). <br>
        Sono presenti anche i messaggi per i 3 movimenti che dovrà compiare il robot: 
        <ol>
            <li>raggiungere la <b>INDOOR</b></li>
            <li>raggiungere la <b>ColdRoom</b></li>
            <li>ritornare in posizione <b>HOME</b></li>
        </ol>
    </p>
    <img class="bigimglim" src="../images/sprint1/diag_sequenza.png" alt="Diagramma di sequenza core-business">

    <p>
        Di seguito, è presente invece la fase di inizializzazione tra <i>TransportTrolley</i> e <i>DDR Robot</i>.
    </p>
    <img class="bigimglim" src="../images/sprint1/diag_sequenza_TT_DDR.png" alt="Diagramma di sequenza TT - DDR">

</p>   

    <h3>Architettura logica</h3>
    Trafiletto su contesti e attori prima dell'immagine dell'architettura.
</div>


<h2>Test plans</h2> 

<div class="remark">
    
</div>


<h2>Project</h2> 
 
<div class="remark">

    <h3 id="sagsim_project">ServiceAccessGUISim</h3>
    <p>
        Come anticipato in fase di analisi del problema, si è pensato di implementare questo componente software come un'<b>applicazione web</b>. <br>
    </p>
    <p>
        Abbiamo deciso di sviluppare l'applicazione utilizzando il framework <b>Spring Boot</b>, sia poiché permette di aggiungere funzionalità in poco tempo, sia allo scopo di uniformare lo stack tecnologico utilizzato dal progetto nel suo insieme (utilizzeremo <i>Spring</i> anche all'interno del <a href="#mapconfigurator_project">MapConfigurator</a>). 
    </p>
    <h5>Architettura dell'applicazione</h5>
    <h6>Comunicazione con il ColdStorageService</h6>
<p>
    Questa applicazione serve per accedere ai servizi forniti dal <i>ColdStorageService</i>. La comunicazione con esso è quindi di cruciale importanza.
</p>
    <p>
        Abbiamo decisio di implementare la comunicazione tra le due componenti software tramite il protocollo <b>Coap</b>. Questa scelta è stata mossa dal fatto che la nostra software house ha già sviluppato classi e interfacce per implementare un concetto generale di connessione tramite appunto il protocollo <i>Coap</i>, all'interno della libreria <code class="docutils literal notranslate"><span class="pre">unibo.basicomm23</span></code>.
    </p>
    <p>
        Nello <a href="../Sprint0/ColdStorageServiceSprint0V1.html">Sprint0</a> abbiamo poi parlato del concetto di attori e del linguaggio <b>Qak</b>. Infatti, un fattore fondamentale che ci ha spinto a scegliere <i>Coap</i> come protocollo di comunicazione è che ogni attore è definito come una risorsa <b>CoapObservable</b> (osservabile tramite la classe <i>CoapObserver</i> definita nella suddetta libreria).
    </p>
    <h6>Diagramma delle classi</h6>
    <p>
        Nell'immagine seguente viene mostrato il <b>diagramma UML</b> delle classi del back-end dell'applicazione Web. 
    </p>
    <img class="bigimglim" src="../images/sprint1/architettura_logica_SAGSim.png" alt="Architettura logica Service Access Gui Simulata, realizzata in Spring">
    <p>
        Prendiamo in analisi i singoli componenti:
        <ul>
            <li><b>SagController</b>: WebServer Controller dell'applicazione definito tramite annotazione del framework <i>SpringBoot</i>. Si occupa di inizializzare l'applicazione definendo un osservatore sull'attore interessato; funge poi da mediatore tra UI e back-end per l'invio al <i>ColdStorageService</i> della richiesta di deposito.</li>
            <li><b>SagConnection</b>: componente che si occupa di stabilire, tramite <code class="docutils literal notranslate"><span class="pre">unibo.basicomm23</span></code>, una connessione <b>Coap</b> con l'attore interessato nel progetto <i>ColdStorageService</i>; permette poi di implementare la comunicazione con l'attore stesso relativamente alla richiesta di deposito.</li>
            <li><b>ConnectionUtils</b>: definisce una nuova <i>CoapConnection</i>.</li>
            <li><b>CoapObserver</b>: osservatore che, ad ogni aggiornamento emesso dal ColdStorageService, avvisa tutte le entità registrate ad esso tramite <i>WebSocket</i>.</li>
        </ul>
        <p>
            Per l'aggiornamento automatico della pagina da parte del server utilizziamo le <b>WebSocket</b>. Abbiamo infatti un file <a href="../../projects/springSAGSim/src/main/resources/static/js/ws_utils.js">ws_utils.js</a> che definisce la connessione e gestisce i messaggi in arrivo in maniera opportuna. <br>
            <ul>
                <li><b>WebSocketConfiguration</b>: implementa la classe <i>WebSocketConfigurer</i> di <code class="docutils literal notranslate"><span class="pre">org.springframework.web.socket.config.annotation</span></code>.</li>
                <li><b>WebSocketHandler</b>: memorizza le sessioni registrate e alle quali inviare i messaggi.</li>
            </ul>
        </p>
    </p>
    <h5>Configurazione</h5>
    <p>Alcuni importanti parametri dell'applicazione possono essere configurati dal file <b>application.properties</b>.</p>
    <img class="imglim" src="../images/sprint1/application_properties.png" alt="File di configurazione application.properties">
    <p>
        Oltre a poter configurare il nome dell'applicazione che apparirà in alto nella pagina web e il banner da mostrare in console, sono presenti:
        <ul>
            <li>server.port, per configurare la porta sulla quale apparirà la pagina web</li>
            <li>actor.name, per definire il nome dell'attore da osservare e al quale verrà inviata la richiesta di deposito</li>
            <li>actor.ctx.*, per specificare tutte le informazioni relative al contesto in cui è presente l'attore d'interesse</li>
        </ul>
    </p>
    <h5>Front-end</h5>
    <p>
        Per la realizzazione della grafica dell'applicazione si fa uso di <b>Bootstrap</b>, una libreria utile per realizzare pagine web reattive e mobile-first, con HTML, CSS e JavaScript;
    </p>
    <img class="bigimglim" src="../images/sprint1/frontend_SAGSim.png" alt="Frontend Service Access Gui Simulata">
    <p>
        L'applicazione permette di inserire una quantità numerica che rappresenta i kg di carico da depositare e, previa validazione dell'input con eventuale toast di errore, invia la richiesta al <i>ColdStorageService</i>. <br>
        A questo punto possono presentarsi tre casi:
        <ul>
            <li>richiesta <b>accettata</b>: l'utente viene notificato dell'accettazione della richiesta, indicandogli di attendere la presa in carico. 
                <p>
                    In questo contesto, due casi sono possibili:
                <ul>
                    <li>se passa troppo tempo, il messaggio viene dato per perso, avvisando l'utente e ricaricando la pagina</li>
                    <li>arriva il messaggio di presa in carico, che viene mostrato in pagina, per poi ricaricarla</li>
                </ul>
                </p>
            </li>
            <li>richiesta <b>rifiutata</b>: l'utente viene avvisato del rifiuto e la pagina web si ricarica, permettendo una nuova interazione.</li>
            <li><b>errore</b> in fase di richiesta: se la richiesta non va a buon fine o passa troppo tempo, l'utente viene notificato e la pagina web si ricarica, permettendo una nuova interazione.</li>
        </ul>
    </p>
    
    <h3>ColdStorageService</h3>

    <p>
        Si riporta di seguito l'architettura logica del ColdStorageService.
    </p>

    <img class="imglim imgborder" src="../images/sprint1/coldstorageservice23arch.png"></img>

    <p>
        Gli attori <b>coldstorageservice</b> e <b>transporttrolley</b> in questa versione risiedono nello stesso contesto.
    </p>

    <h5>coldstorageservice</h5>

    <p>
        <b>coldstorageservice</b> &egrave; incaricato di comunicare con la ServiceAccessGUISim: gestisce la richiesta di deposito accettandola se la ColdRoom pu&ograve; contenere il carico richiesto, rifiutandola altrimenti.

        A questo scopo si utilizzano le variabili e constanti:
        <ul>
            <li><code class="docutils literal notranslate"><span class="pre">val maxColdRoom: Float</span></code>: mantiene il peso massimo che la ColdRoom pu&ograve; contenere</li> 
            <li><code class="docutils literal notranslate"><span class="pre">var currentColdRoom: Float</span></code>: memorizza il peso corrente contenuto nella ColdRoom</li> 
        </ul>

        Se la richiesta viene accettata il <b>coldstorageservice</b> invia il messaggio <b>deposit</b> al <b>transporttrolley</b> e si mette in attesa di altre richieste; quando e se riceve un messaggio <b>chargetakentt</b> dal transporttrolley utilizza il comando <code class="docutils literal notranslate"><span class="pre">updateResource</span></code> per notificare gli observer, e quindi la ServiceAccessGUISim, che il carico &egrave; stato prelevato.
    </p>

    <h5>transporttrolley</h5>

    <p>
        Il <b>transporttrolley</b> &egrave; incaricato di comunicare al basicrobot dove dovr&agrave; spostare il VirtualRobot.
    </p>

    <p>
        All'inizializzazione viene ingaggiato il basicrobot tramite <b>engage</b>, viene poi usato <b>setrobotstate</b> per impostare la posizione iniziale a (0,0) direzione d.
    </p>

    <p>
        Quando riceve un messaggio <b>deposit</b> l'attore comunica al basicrobot di spostarsi a INDOOR tramite il messaggio <b>moverobot</b>, successivamente comunica a coldstorageservice che il carico &egrave; stato prelevato con il messaggio <b>chargetakentt</b>, muove poi il basicrobot in ColdRoom, comunincando infine l'avvenuto deposito con il messaggio <b>chargedeposited</b>.
    </p>

    <p>
        Durante uno qualsiasi degli stati che l'attore assume durante lo spostamento &egrave; in grado di gestire un messaggio <b>deposit</b> tramite interrupt, aggiungendolo a una coda per gestirlo quando possibile.
    </p>

    <p>
        <b>CI SONO DEI RAGIONAMENTI DA FARE:
            <ul>
                <li>come memorizziamo lo spazio disponibile? C'è una terza entità che lo fa?</li>
                <li>come scegliamo se accettare o meno la risposta</li>
            </ul>
        </b>
    </p>

    <h3 id="mapconfigurator_project">MapConfigurator</h3>

    <p>
        MapConfigurator &egrave; una <b>applicazione grafica web</b> che permette a un utente di creare una configurazione per la disposizione dei punti di interesse nella service area.
    </p>
    <p>
        Come per la <a href="#sagsim_project">ServiceAccessGUI Simulata</a> utilizziamo il framework <b>Spring Boot</b>.
    </p>

    <div class="imgslide">
        <figure>
            <img class="imglim img-border" src="../images/sprint1/mapconfempty.png" alt="Interfaccia MapConfigurator">
        </figure>
        <figure>
            <img class="imglim img-border" src="../images/sprint1/mapconf.png" alt="Interfaccia MapConfigurator">
        </figure>
    </div>

    <p>
        Le feature principali dell'applicazione includono:
        <ul>
            <li><b>blocchi trascinabili</b>: la griglia viene compilata trascinando i blocchi che rappresentano i landmark con una funzionalit&agrave; di <b>drag and drop</b>;</li>
            <li><b>griglia ridimensionabile</b>: &egrave; possibile ridimensionare la griglia tramite gli slider in alto, la dimensione di <i>default</i> &egrave; quella individuata utilizzando <code class="prettyprint">unibo.mapperQak23</code></li>
            <li><b>persistenza</b>: l'utente trover&agrave; la configurazione creata salvata tra sessioni, permettendo di riprendere la modifica dove era stata lasciata</li>
            <li><b>utilizzo intuitivo</b>: l'applicazione deve essere semplice da utilizzare nascondendo i dettagli della rappresentazione utilizzata dal planner</li>
        </ul>
    </p>

    <p>
        I blocchi trascinati sulla mappa vengono considerati come <b>esplorati</b> e, nel caso del blocco della <span class="bold" style="color:rgb(64,64,228);">ColdRoom</span> marcati come <b>ostacoli</b> nella rappresentazione sotto forma di <code class="prettyprint">unibo.planner23.model.RoomMap</code>.
    </p>

    <p>
        Questa applicazione &egrave; completa nel rispetto delle funzionalit&agrave; di base che abbiamo considerato necessarie, &egrave; possibile tuttavia che in futuro verr&agrave; estesa con feature di utilit&agrave; aggiuntive.
    </p>
    
    <h5>Diagramma delle classi</h5>

    <p>
        Di seguito si riporta il <b>diagramma UML</b> delle classi dell'applicazione.
    </p>
        <img class="bigimglim" src="../images/sprint1/mapConfiguratorUML.png" alt="Diagramma UML">


</div>

<h2>Testing</h2> 
 
<div class="remark">

</div>

<h2>Deployment</h2> 



<div class="remark">

    <h4>Distribuzione</h4>

    <p>
        Per il deployment di queste applicazioni si &egrave; deciso di utilizzare <a href="https://www.docker.com/">Docker</a>, questo ci permetter&agrave; di <i>uniformare</i> la metodologia di gestione della distribuzione dei vari componenti del servizio.
    </p>

    <p>
        In particolare abbiamo creato dei Dockerfile, utilizzando l'apposito linguaggio dichiarativo, usati poi per creare le <a href="https://docs.docker.com/glossary/#image">immagini</a> che faranno parte dei <a href="https://docs.docker.com/glossary/#container">container</a> che eseguono i servizi.
    </p>

    <p>
        Si riporta di seguito il Dockerfile usato per generare l'immagine di mapConfigurator.
    </p>

    <pre><code class="language-docker">FROM openjdk:11
EXPOSE 8015
VOLUME ["/data"]
ADD ./build/distributions/unibo.mapConfigurator-boot-2.2.tar /
WORKDIR unibo.mapConfigurator-boot-2.2/bin
CMD ["bash", "./unibo.mapConfigurator"]</code></pre>

    <p>
        Allo scopo di velocizzare la creazione dei Dockerfile e delle rispettive immagini abbiamo implementato una serie di task Gradle che automatizzano questo compito, &egrave; possibile visualizzare queste task in un qualsiasi file build.gradle.kts (<a about="_blank" href="../../projects/unibo.mapConfigurator/build.gradle.kts">esempio</a>)
    </p>

    <p>
        Tutte le immagini relative a questo progetto saranno rese disponibili online a questo profilo <a about="_blank" href="https://hub.docker.com/u/riccardoob">Docker Hub</a>
    </p>

    <h5>Controllo</h5>
    
    <p>
        Dato il numero elevato di servizi da gestire verr&agrave; progettata e messa a disposizione del cliente una applicazione dedicata alla gestione dei componenti del servizio, permetter&agrave; di manipolare impostazioni e valori di default delle applicazioni tramite una interfaccia grafica.
    </p>

</div>
 
<h2>Maintenance</h2> 
 
<div class="remark">

</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
GIT repo: https://github.com/RiccardBarbieri/ColdStorageService
</div>
</div>
</body>
</html>
