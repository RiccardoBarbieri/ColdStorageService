System coldstorageservice23



Request 	storerequest	:	storerequest(FW)
Reply 		storereply		:	storereply(TICKET,OKREJ)

Request		codeentered		:	codeentered(TICKET)
Reply		ticketreply		:	ticketreply(TICKET,OKREJ)

Event		rejrequpdate	:	rejrequpdate(NREJ)

Dispatch	newcharge		:	newcharge(FW)

Dispatch	chargetakentt	:	chargetakentt(arg)
Dispatch	chargetaken		:	chargetaken(TICKET)

Dispatch	chargedeposited	:	chargedeposited(FW)

Event		coldroomupdate	:	coldroomupdate(KG)

Event		statusupdate	:	statusupdate(POS, STATE)

Dispatch	stop			:	stop(arg)
Dispatch	resume			:	resume(arg)



Context ctx_coldstorageservice ip [host="localhost" port=8021]
Context ctx_access ip [host="localhost" port=8022]
Context ctx_statusmonitor ip [host="localhost" port=8023]
Context ctx_alarmsystem ip [host="localhost" port=8024]

Context ctx_basicrobot ip [host="127.0.0.1" port=8020]


ExternalQActor basicrobot context ctx_basicrobot


QActor coldstorageservice context ctx_coldstorageservice {
	
	[#var TICKETTIME = 30
		var MAXW = 100
		var CurrentColdRoom = 0f
		var TicketMap : HashMap<String, Pair<Float, Long>> = HashMap<String, Pair<Float, Long>>()
		var TicketList : MutableList<String> = mutableListOf<String>()
		var ReqRejected = 0
	#]
	
	State s0 initial {
		
	}
	Goto work
	
	State work {
		printCurrentMessage
	}
	Transition t0 whenRequest storerequest -> elabStorerequest
				  whenRequest codeentered -> elabCodeentered
				  whenMsg	  chargetakentt -> elabChargetaken
				  whenMsg	  chargedeposited -> elabChargedeposited
	
	State elabStorerequest {
		//funzione mock, verr√† cambiata
		[# var CurrentTime = 0L
			var CurrentTicket = ""
			fun generateNextTicket(existingMap: HashMap<String, Pair<Float, Long>>): String {
    			val alphabets = ('A'..'Z').toList()
    			val numbers = (0..9).toList()

			    while (true) {
			        val randomChars = (1..3).map { alphabets.random() }
			        val randomNumbers = (1..3).map { numbers.random() }
			        val randomString = (randomChars + randomNumbers).joinToString("")

		    	    if (!existingMap.containsKey(randomString)) {
			            return randomString
		    	    }
    			}
			}
		#]
		onMsg( storerequest : storerequest(FW) ) {
			if [# CurrentColdRoom + payloadArg(1).toInt() <= MAXW #] {
				memoCurrentTime CurrentTime
				[# CurrentTicket = generateNextTicket(TicketMap)
				TicketMap.put(CurrentTicket, Pair(payloadArg(1).toFloat(), CurrentTime)) 
				TicketList.add(CurrentTicket)
				#]
				println("CSS | Accepted request for $payloadArg(1) kilograms")
				replyTo storerequest with storereply : storereply($CurrentTicket,OK)
			}
			else {
				println("CSS | Rejected request for $payloadArg(1) kilograms, not enough space")
				replyTo storerequest with storereply : storereply(NULL,REJ)
				[# ReqRejected += 1 #]
				//notifica
			}
		}
	}
	Goto work
	
	State elabCodeentered {
		
		[# var Elapsed = 0L #]
		
		onMsg ( codeentered : codeentered(TICKET) ) {
			[# var TicketStart = TicketMap.get(payloadArg(1))!!.second #]
			setDuration Elapsed from TicketStart
			if [# Elapsed > TICKETTIME * 1000 #] {
				[# TicketMap.remove(payloadArg(1)) #]
				replyTo codeentered with ticketreply : ticketreply(NULL,REJ)
				[# ReqRejected += 1 #]
				//notifica
				println("CSS | Rejected code confirmation, ticket $payloadArg(1) has expired")
			} else {
				[# var CurrentFW = TicketMap.get(payloadArg(1))!!.first #]
				replyTo codeentered with ticketreply : ticketreply($payloadArg(1),OK)
				forward transporttrolley -m newcharge : newcharge($CurrentFW)
				println("CSS | Accepted code confirmation for ticket $payloadArg(1)")
				[# CurrentColdRoom += payloadArg(1).toFloat() #]
			}
		}
	}
	Goto work
	
	State elabChargetaken {
		[# var CurrentTicketServed = TicketList.removeAt(0) #]
		forward serviceaccessgui -m chargetaken : chargetaken($CurrentTicketServed)
		[# TicketMap.remove(CurrentTicketServed) #]
		println("CSS | TransportTrolley has taken current load")
	}
	Goto work
	
	State elabChargedeposited {
		onMsg ( chargedeposited : chargedeposited(FW) ) {
			println("CSS | TranportTrolley has deposited $payloadArg(1) kilograms in the ColdRoom")
			//notifica ColdRoom update
		}
	}
}


QActor transporttrolley context ctx_coldstorageservice {
	
	State s0 initial {
		
	}
}

QActor serviceaccessgui context ctx_access {
	
	[#var TicketList = mutableListOf<String>()
	#]
	
	State s0 initial {
		delay 3000
		request coldstorageservice -m storerequest : storerequest(30)
	}
	Goto work
	
	State work {
		printCurrentMessage color green
	}
	Transition t0 whenReply storereply -> handleStorereply
				  whenReply ticketreply -> handleTicketreply
				  whenMsg	chargetaken -> handleChargetaken
	
	State handleStorereply {
		[# var IsRequestRejected = false #]
		onMsg( storereply : storereply(TICKET, OKREJ) ) {
			if [# payloadArg(2) == "REJ" #] {
				println("SAG | Store request rejected, not enough space") color red
				[# IsRequestRejected = true #]
			}
			else {
				println("SAG | Store request accepted, your ticket number is $payloadArg(1)") color blue
				[#
					TicketList.add(payloadArg(1))
				#]
			}
		}
	}
	Goto work if [# IsRequestRejected #] else insertCode
	
	State insertCode {
		delay 2000
		//mock ticket
		[#var CurTicket = TicketList.indexOf(0) 
		#]
		request coldstorageservice -m codeentered : codeentered($CurTicket)
	}
	Goto work
	
	State handleTicketreply {
		onMsg( ticketreply : ticketreply(TICKET,OKNO) ) {
			if [# payloadArg(2) == "REJ" #] {
				println("SAG | You did not reach INDOOR in time, the request is forfeit") color red
			}
			else {
				println("SAG | Ticket accepted, wait here for cargo unload") color blue
				[# TicketList.remove(payloadArg(1)) #]
			}
		}
	}
	Goto work
	
	State handleChargetaken {
		onMsg( chargetaken : chargetaken(TICKET) ) {
			println("SAG | Ticket $payloadArg(1) can move away from INDOOR")
			delay 500
		}
	}
	Goto s0
}

QActor servicestatusgui context ctx_statusmonitor {
	
	State s0 initial {
		
	}
}


QActor warningdevice context ctx_alarmsystem {
	
	State s0 initial {
		
	}
	
}

QActor alarmdevice context ctx_alarmsystem {
	
	State s0 initial {
		
	}
	
}







