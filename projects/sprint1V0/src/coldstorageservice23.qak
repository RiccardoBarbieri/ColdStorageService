System coldstorageservice23

//SAG -> CSS
Request 	storerequest		:		storerequest(FW)

//CSS -> SAG
Reply		loadaccepted		:		loadaccepted(arg) for storerequest
Reply		loadrejected		:		loadrejected(arg) for storerequest
Dispatch	chargetaken			:		chargetaken(arg)

//TT -> CSS
Dispatch	chargetakentt		:		chargetaken(arg)
Dispatch	chargedeposited		:		chargedeposited(arg)

//CSS -> TT
Dispatch	deposit				:		deposit(arg)

//TT -> TE
Request		move				:		move(X,Y)
Request		moveclosest			:		moveclosest(Xs,Ys)

//TE -> TT
Reply		movedone			:		movedone(arg) for move
Reply		movefailed			:		movefailed(arg) for move
Reply		movecdone			:		movecdone(arg) for moveclosest
Reply		movecfailed			:		movecfailed(arg) for moveclosest
Dispatch	fail				:		fail(ERROR)


//BASICROBOT
Request		engage				:		engage(OWNER, STEPTIME)
Reply		engagedone			:		engagedone(ARG) for engage
Reply		engagerefused		:		engagerefused(ARG) for engage
Dispatch	disengage			:		disengage(ARG)

Request		moverobot			:		moverobot(TARGETX, TARGETY)
Reply		moverobotdone		:		moverobotok(ARG) for moverobot
Reply		moverobotfailed		:		moverobotfailed(PLANDONE, PLANTODO) for moverobot

Dispatch	setrobotstate		:		setpos(X,Y,D)

Event		alarm				:		alarm(X)

Request		getrobotstate		:		getrobotstate(ARG)
Reply		robotstate			:		robotstate(POS,DIR) for getrobotstate



Context ctxbasicrobot ip [host="127.0.0.1" port=8020]
Context ctx_coldstorageservice ip [host="localhost" port=8021]


QActor coldstorageservice context ctx_coldstorageservice {
	
	[#	val maxColdRoom: Float = 10F
		var currentColdRoom: Float = 0F
		var accepted: Boolean = false
	#]
	
	State s0 initial {
		println("CSS: started") color blue
	}
	Goto waiting
	
	State waiting {
		println("CSS: waiting for new storage request") color blue
	}
	Transition t0	whenRequest		storerequest	->	checkAvailability
					whenInterrupt	chargetakentt	->	finalizeDeposit
					whenInterrupt	chargedeposited	->	chargeDeposited
	
	State checkAvailability {
		onMsg (storerequest : storerequest(FW)) {
			[# val FW = payloadArg(0).trim().toFloat() #]
						
			if [# (currentColdRoom + FW) <= maxColdRoom #] {
				replyTo storerequest with loadaccepted : loadaccepted(arg)
				println("CSS: load for $FW KG accepted, currentWeight = $currentColdRoom") color blue
				[#	currentColdRoom += FW
					accepted = true	
				#]
			} else {
				[# accepted = false #]
				replyTo storerequest with loadrejected : loadrejected(arg)
				println("CSS: load for $FW KG rejected, not enough space in ColdRoom, currentWeight = $currentColdRoom") color blue
			}
		}
	}
	
	Goto forwardDeposit if [# accepted #] else waiting
	
	State forwardDeposit {
		[# accepted = false #]
		forward transporttrolley -m deposit : deposit(arg)
	}
	Goto waiting

	State finalizeDeposit {
		println("CSS: charge taken") color blue
		//TODO: bring FW here
		updateResource [# "chargetaken" #]
		returnFromInterrupt
	}
	
	State chargeDeposited {
		println("CSS: current load deposited in ColdRoom, currentWeight = $currentColdRoom") color blue
		returnFromInterrupt
	}
	
}

QActor transporttrolley context ctx_coldstorageservice {
	
	[#	val landmarkConf = utils.MapUtils.loadMapConfiguration("servicearea")
		var Anywhere: Pair<Int, Int> = Pair(0,0)
		
		val HomeToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", Pair(0,0))
		val IndoorToPortCoord = landmarkConf.getCoordinateClosestToFor("P", HomeToIndoorCoord)
		val PortToHomeCoord = landmarkConf.getCoordinateClosestToFor("H", IndoorToPortCoord)
		val PortToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", IndoorToPortCoord)
		
		val depositQueue: java.util.Queue<Int> = java.util.LinkedList<Int>()
		
		var returnHome: Boolean = false
		
	#]
	
	
	State s0 initial {
		println("TT: started") color green
	}
	Goto waiting
//	Goto test
	
	
//	_______________________________________________________________
//	Transition t0	whenReply engagedone	->	test
//					whenReply engagerefused	->	engageFailed

//	State test {
//		println("${HomeToIndoorCoord}, ${IndoorToPortCoord}, ${PortToHomeCoord}")
//	}
//	
//	
//	State test {
//		[# var X = IndoorToPortCoord.first + 2
//			var Y = IndoorToPortCoord.second
//		#]
//		forward basicrobot -m setrobotstate : setpos(0,0,l)
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		[# Y -= 1 #]
//		
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		[# Y -= 1 #]
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		request basicrobot -m moverobot : moverobot(0,0)
//		
//		
//		request basicrobot -m getrobotstate : getrobotstate(arg)
//		
//	}
//	Transition t0	whenReply	robotstate		->	temp
//	
//	
//	State temp {
//		onMsg (robotstate : robotstate(pos(X,Y),D)) {
//			println("${payloadArg(0)}, ${payloadArg(1)}")
//		}
//	}
//	_____________________________________________________________________
	
//	State engageFailed {
//		println("TT: contact with basicrobot failed on engage, try restarting the application") color green
//	}
	
	State moveFailed {
		println("TT: contact with trolleyexecutor failed on move, try restarting the application") color green
	}
	
	State somethingFailed {
		onMsg(fail : fail(ERROR)) {
			println("TT: TE failed with error -> ${payloadArg(0)}")
		}
	}
		
	State waiting {
		println("TT: waiting for new deposit request") color green
	}
	Transition t0	whenMsg	deposit	->	moveToIndoorFromHome
					whenMsg	fail	->	somethingFailed
	
	State queueDeposit {
		[#	depositQueue.add(0)
		#]
		println("TT: added deposit request to queue") color green
		returnFromInterrupt
	}
	
	State restartToIndoor {
		println("TT: restarting to indoor") color green
		
		[#	val destinations = landmarkConf.getCoordinatesFor("I")
			val messages = utils.PosUtils.listOfDestToMessStrings(destinations)
			val Xs = messages.first
			val Ys = messages.second
		#]
		
		request trolleyexecutor -m moveclosest : moveclosest($Xs,$Ys)
	}
	Transition t0	whenReply	 	movecdone	->	takeCharge
					whenReply		movecfailed	->	moveFailed
					whenInterrupt	deposit		->	queueDeposit
	
	State moveToIndoorFromHome {
		[#	val X = HomeToIndoorCoord.first
			val Y = HomeToIndoorCoord.second
		#]
		request trolleyexecutor -m move : move($X,$Y)
		println("TT: moving robot to indoor") color green
	}
	Transition t0	whenReply	 	movedone		->	takeCharge
					whenReply		movefailed		->	moveFailed
					whenInterrupt	deposit			->	queueDeposit
	
	State takeCharge {
		println("TT: loading charge") color green
		delay 1000
		println("TT: charge loaded") color green
	}
	Goto chargeTaken
	
	State chargeTaken {
		forward coldstorageservice -m chargetakentt : chargetakentt
	}
	Goto toPort
	
	State toPort {
		[#	val X = IndoorToPortCoord.first
			val Y = IndoorToPortCoord.second
		#]
		println("TT: moving to access port") color green
		request trolleyexecutor -m move : move($X,$Y)
	}
	Transition t0	whenReply		movedone	->	depositInColdRoom
					whenReply		movefailed	->	moveFailed
					whenInterrupt	deposit		->	queueDeposit
					
	State depositInColdRoom {
		delay 1000
		forward coldstorageservice -m chargedeposited : chargedeposited(arg)
		println("TT: charge deposited") color green
	}
	Goto checkQueueOrReturn
	
	State checkQueueOrReturn {
		[#	returnHome = (depositQueue.size == 0) #]
		if [# returnHome #] {
			[#	val X = PortToHomeCoord.first
				val Y = PortToHomeCoord.second
			#]
			request trolleyexecutor -m move : move($X, $Y)
			println("TT: no queued requests, returning to home") color green
		}
		else {
			[#	depositQueue.remove()
				val X = PortToIndoorCoord.first
				val Y = PortToIndoorCoord.second
			#]
			request trolleyexecutor -m move : move($X, $Y)
			println("TT: managing queued request, returning to indoor") color green
		}
	}
	Transition t0	whenMsg		deposit							->	restartToIndoor
					whenReply	movedone and [# returnHome #]	->	waiting
					whenReply	movedone and [# !returnHome #]	->	takeCharge
					whenReply	movefailed						->	moveFailed
	
	
}

QActor trolleyexecutor context ctx_coldstorageservice {
	
	[#	var isMoving = false
		var destinations = mutableListOf<Pair<Int,Int>>()
	#]
	
	
	State s0 initial {
		println("TE: trolleyexecutor initialized") color magenta
	}
	Goto engage
	
	State engage {
		request basicrobot -m engage : engage(trolleyexecutor, 300)
	}
	Transition t0	whenTime	10000			->	engageFail
					whenReply	engagedone		->	setState
					whenReply	engagerefused	->	engageFail
					
	State engageFail {
		[# val ErrorString = "Ingaggio robot fallito" #]
		forward transporttrolley -m fail : fail($ErrorString)
		println("TE: engage with robot failed, try restarting the application") color magenta
	}
	
	State moveFail {
		replyTo move with movefailed : movecfailed(arg)
		println("TE: moverobot failed, try restarting the application") color magenta
	}
	
	State movecFail {
		replyTo move with movefailed : movecfailed(arg)
		println("TE: moverobot failed, try restarting the application") color magenta
	}
	
	State timeout {
		println("TE: connection with basicrobot timed out") color magenta
	}
	
	State setState {
		forward basicrobot -m setrobotstate : setpos(0,0,d)
	}
	Goto waiting
	
	State waiting {
		println("TE: waiting") color magenta
	}
	Transition t0	whenRequest	move		->	move
					whenRequest	moveclosest	->	stop
	
	State move {
		println("TE: move") color magenta
		onMsg (move : move(X,Y)) {
			[#	val X = payloadArg(0)
				val Y = payloadArg(1)
			#]
			request basicrobot -m moverobot : moverobot($X,$Y)
			[# isMoving = true #]
		}
	}
	Transition t0	whenTime	30000			->	timeout
					whenReply	moverobotdone	->	moveCompleted
					whenReply	moverobotfailed	->	moveFail
					
	State stop {
		println("TE: moveClosest") color magenta
		onMsg (moveclosest : moveclosest(Xs,Ys)) {
			[# destinations = utils.PosUtils.destStringListToPairs(payloadArg(0), payloadArg(1)) #]
			if [# isMoving #] {
				emit alarm : alarm(arg)
				[# isMoving = false #]
			}
		}
	}
	Goto askPosition
	
	State askPosition {
		println("TE: askPosition")
		request basicrobot -m getrobotstate	: getrobotstate(arg)
	}
	Transition t0	whenTime	30000		->	timeout
					whenReply	robotstate	->	moveClosest
	
	State moveClosest {
		println("TE: moveClosest")
		onMsg (robotstate : robotstate(POS,DIR)) {
			[#	val position = utils.PosUtils.posStringToPair(payloadArg(0).trim())
				
				val closest = utils.PosUtils.closestDestination(position, destinations)
				val X = closest.first
				val Y = closest.second
			#]
			
			request basicrobot -m moverobot : moverobot($X,$Y)
			[# isMoving = true #]
		}
	}
	Transition t0	whenTime	30000			->	timeout
					whenReply	moverobotdone	->	movecCompleted
					whenReply	moverobotfailed	->	movecFail
					
	State moveCompleted {
		[# isMoving = false #]
		println("TE: moveCompleted") color magenta
		replyTo move with movedone : movedone(arg)
	}
	Goto waiting
	
	State movecCompleted {
		[# isMoving = false #]
		println("TE: movecCompleted") color magenta
		replyTo moveclosest with movecdone : movecdone(arg)
	}
	Goto waiting

//	State stopAskPos {
//		discardMsg On
//		println("TE: stopAskPos") color magenta
//		emit alarm : alarm(arg)
//		[# isMoving = false #]
//		request basicrobot -m getrobotstate : getrobotstate(arg)
//	}
//	Transition t0	whenTime	30000		->	timeout
//					whenReply	robotstate	->	sendPosition
//
//	State askPosition {
//		println("TE: askPosition") color magenta
//		request basicrobot -m getrobotstate : getrobotstate(arg)
//	}
//	Transition t0	whenTime	30000		->	timeout
//					whenReply	robotstate	->	sendPosition
//	
//	State sendPosition {
//		println("TE: sendPosition") color magenta
//		onMsg (robotstate : robotstate(POS,DIR)) {
//			[#	val position = utils.PosUtils.posStringToPair(payloadArg(0).trim())
//				
//				val X = position.first
//				val Y = position.second
//			#]
//			replyTo getposition with position : position($X,$Y)
//		}
//	}
//	Goto waiting

}




ExternalQActor basicrobot context ctxbasicrobot



