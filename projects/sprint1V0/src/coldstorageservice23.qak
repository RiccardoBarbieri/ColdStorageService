System coldstorageservice23

//SAG -> CSS
Request 	storerequest		:		storerequest(FW)

//CSS -> SAG
Reply		loadaccepted		:		loadaccepted(arg)
Reply		loadrejected		:		loadrejected(arg)
Dispatch	chargetaken			:		chargetaken(arg)

//TT -> CSS
Dispatch	chargetakentt		:		chargetaken(arg)
Dispatch	chargedeposited		:		chargedeposited(arg)

//CSS -> TT
Dispatch	deposit				:		deposit(arg)


//BASICROBOT
Dispatch	cmd					:		cmd(arg)
Dispatch	step				:		step(arg)

Request		engage				:		engage(OWNER, STEPTIME)	
Reply		engagedone			:		engagedone(ARG)
Reply		engagerefused		:		engagerefused(ARG)
Dispatch	disengage			:		disengage(ARG)

Request		moverobot			:		moverobot(TARGETX, TARGETY)
Reply		moverobotdone		:		moverobotok(ARG)
Reply		moverobotfailed		:		moverobotfailed(PLANDONE, PLANTODO)

Dispatch	setrobotstate		:		setpos(X,Y,D)

Event		alarm				:		alarm(X)

Request		getrobotstate		:		getrobotstate(ARG)
Reply		robotstate			:		robotstate(POS,DIR)



Context ctxbasicrobot ip [host="127.0.0.1" port=8020]
Context ctx_coldstorageservice ip [host="localhost" port=8021]


QActor coldstorageservice context ctx_coldstorageservice {
	
	[#	val maxColdRoom: Float = 10F
		var currentColdRoom: Float = 0F
		var accepted: Boolean = false
	#]
	
	State s0 initial {
		println("CSS: started") color blue
	}
	Goto waiting
	
	State waiting {
		println("CSS: waiting for new storage request") color blue
	}
	Transition t0	whenRequest		storerequest	->	checkAvailability
					whenInterrupt	chargetakentt	->	finalizeDeposit
					whenInterrupt	chargedeposited	->	chargeDeposited
	
	State checkAvailability {
		onMsg (storerequest : storerequest(FW)) {
			[# val FW = payloadArg(0).trim().toFloat() #]
						
			if [# (currentColdRoom + FW) <= maxColdRoom #] {
				replyTo storerequest with loadaccepted : loadaccepted(arg)
				println("CSS: load for $FW KG accepted, currentWeight = $currentColdRoom") color blue
				[#	currentColdRoom += FW
					accepted = true	
				#]
			} else {
				[# accepted = false #]
				replyTo storerequest with loadrejected : loadrejected(arg)
				println("CSS: load for $FW KG rejected, not enough space in ColdRoom, currentWeight = $currentColdRoom") color blue
			}
		}
	}
	Goto forwardDeposit if [# accepted #] else waiting
	
	State forwardDeposit {
		[# accepted = false #]
		forward transporttrolley -m deposit : deposit(arg)
	}
	Goto waiting

	State finalizeDeposit {
		println("CSS: charge taken") color blue
		//TODO: bring FW here
		updateResource [# "chargetaken" #]
		returnFromInterrupt
	}
	
	State chargeDeposited {
		println("CSS: current load deposited in ColdRoom, currentWeight = $currentColdRoom") color blue
		returnFromInterrupt
	}
	
}

QActor transporttrolley context ctx_coldstorageservice {
	
	[#	val landmarkConf = utils.MapUtils.loadMapConfiguration("servicearea")
		var Anywhere: Pair<Int, Int> = Pair(0,0)
		
		val HomeToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", Pair(0,0))
		val IndoorToPortCoord = landmarkConf.getCoordinateClosestToFor("P", HomeToIndoorCoord)
		val PortToHomeCoord = landmarkConf.getCoordinateClosestToFor("H", IndoorToPortCoord)
		val PortToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", IndoorToPortCoord)
		
		val depositQueue: java.util.Queue<Int> = java.util.LinkedList<Int>()
		
		var returnHome: Boolean = false
		
	#]
	
	
	State s0 initial {
		println("TT: started") color green
		request basicrobot -m engage : engage(transporttrolley, 300)
	}
	Transition t0	whenReply engagedone	->	setRobot
					whenReply engagerefused	->	engageFailed
//	Goto test
	
	
//	_______________________________________________________________
//	Transition t0	whenReply engagedone	->	test
//					whenReply engagerefused	->	engageFailed

//	State test {
//		println("${HomeToIndoorCoord}, ${IndoorToPortCoord}, ${PortToHomeCoord}")
//	}
//	
//	
//	State test {
//		[# var X = IndoorToPortCoord.first + 2
//			var Y = IndoorToPortCoord.second
//		#]
//		forward basicrobot -m setrobotstate : setpos(0,0,l)
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		[# Y -= 1 #]
//		
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		[# Y -= 1 #]
//		request basicrobot -m moverobot : moverobot($X,$Y)
//		
//		request basicrobot -m moverobot : moverobot(0,0)
//		
//		
//		request basicrobot -m getrobotstate : getrobotstate(arg)
//		
//	}
//	Transition t0	whenReply	robotstate		->	temp
//	
//	
//	State temp {
//		onMsg (robotstate : robotstate(pos(X,Y),D)) {
//			println("${payloadArg(0)}, ${payloadArg(1)}")
//		}
//	}
//	_____________________________________________________________________
	
	State engageFailed {
		println("TT: contact with basicrobot failed on engage, try restarting the application") color green
	}
	
	State moveFailed {
		println("TT: contact with basicrobot failed on moverobot, try restarting the application") color green
	}
	
	State timeout {
		println("TT: connection with basicrobot timed out") color green
	}
	
	State setRobot {
		forward basicrobot -m setrobotstate : setpos(0,0,d)
	}
	Goto waiting
		
	State waiting {
		println("TT: waiting for new deposit request") color green
	}
	Transition t0 whenMsg	deposit	->	moveToIndoorFromHome
	
	State queueDeposit {
		[#	depositQueue.add(0)
		#]
		println("TT: added deposit request to queue") color green
		returnFromInterrupt
	}
	
	State stopAndRestart {
		println("TT: stopping basicrobot") color green
		emit alarm : alarm(arg)
		
		request basicrobot -m getrobotstate : getrobotstate(arg)		
	}
	Transition t0	whenTime	5000		->	timeout
					whenReply	robotstate	->	moveToIndoorFromAnywhere
	
	State moveToIndoorFromAnywhere {
		onMsg (robotstate : robotstate(pos(X,Y),D)) {
			[#	Anywhere = utils.PosUtils.posStringToPair(payloadArg(0).trim())
				
				val AnywhereToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", Anywhere)
				
				val X = AnywhereToIndoorCoord.first
				val Y = AnywhereToIndoorCoord.second
			#]
			request basicrobot -m moverobot : moverobot($X,$Y)
		}
		println("TT: new request, returning to indoor") color green
	}
	Transition t0	whenTime		5000			->	timeout
					whenReply	 	moverobotdone	->	takeCharge
					whenReply		moverobotfailed	->	moveFailed
					whenInterrupt	deposit			->	queueDeposit
	
	State moveToIndoorFromHome {
		[#	val X = HomeToIndoorCoord.first
			val Y = HomeToIndoorCoord.second
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
		println("TT: moving robot to indoor") color green
	}
	Transition t0	whenTime		30000			->	timeout
					whenReply	 	moverobotdone	->	takeCharge
					whenReply		moverobotfailed	->	moveFailed
					whenInterrupt	deposit			->	queueDeposit
	
	State takeCharge {
		println("TT: loading charge") color green
		delay 1000
		println("TT: charge loaded") color green
	}
	Goto chargeTaken
	
	State chargeTaken {
		forward coldstorageservice -m chargetakentt : chargetakentt
	}
	Goto toPort
	
	State toPort {
		[#	val X = IndoorToPortCoord.first
			val Y = IndoorToPortCoord.second
		#]
		println("TT: moving to access port") color green
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Transition t0	whenTime		30000				->	timeout
					whenReply		moverobotdone		->	depositInColdRoom
					whenReply		moverobotfailed		->	moveFailed
					whenInterrupt	deposit				->	queueDeposit
					
	State depositInColdRoom {
		delay 1000
		forward coldstorageservice -m chargedeposited : chargedeposited(arg)
		println("TT: charge deposited") color green
	}
	Goto checkQueueOrReturn
	
	State checkQueueOrReturn {
		[#	returnHome = (depositQueue.size == 0) #]
		if [# returnHome #] {
			[#	val X = PortToHomeCoord.first
				val Y = PortToHomeCoord.second
			#]
			request basicrobot -m moverobot : moverobot($X, $Y)
			println("TT: no queued requests, returning to home") color green
		}
		else {
			[#	depositQueue.remove()
				val X = PortToIndoorCoord.first
				val Y = PortToIndoorCoord.second
			#]
			request basicrobot -m moverobot : moverobot($X, $Y)
			println("TT: managing queued request, returning to indoor") color green
		}
	}
	Transition t0	whenMsg		deposit								->	stopAndRestart
					whenReply	moverobotdone and [# returnHome #]	->	waiting
					whenReply	moverobotdone and [# !returnHome #]	->	takeCharge
					whenReply	moverobotfailed						->	moveFailed
	
	
}


ExternalQActor basicrobot context ctxbasicrobot



