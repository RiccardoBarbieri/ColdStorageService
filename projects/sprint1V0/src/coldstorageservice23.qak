System coldstorageservice23

//SAG -> CSS
Request 	storerequest		:		storerequest(FW)

//CSS -> SAG
Reply		loadaccepted		:		loadaccepted(arg)
Reply		loadrejected		:		loadrejected(arg)
Dispatch	chargetaken			:		chargetaken(arg)

//TT -> CSS
Dispatch	chargetakentt		:		chargetaken(arg)

//CSS -> TT
Dispatch	stop				:		stop(arg)
Dispatch	resume				:		resume(arg)
Dispatch	deposit				:		deposit(arg)

//BASICROBOT
Dispatch	cmd					:		cmd(arg)
Dispatch	step				:		step(arg)

Request		engage				:		engage(OWNER, STEPTIME)	
Reply		engagedone			:		engagedone(ARG)
Reply		engagerefused		:		engagerefused(ARG)
Dispatch	disengage			:		disengage(ARG)

Request		moverobot			:		moverobot(TARGETX, TARGETY)
Reply		moverobotdone		:		moverobotok(ARG)
Reply		moverobotfailed		:		moverobotfailed(PLANDONE, PLANTODO)

Dispatch	setrobotstate		:		setpos(X,Y,D)

Event		alarm				:		alarm(X)

Request		getrobotstate		:		getrobotstate(ARG)
Reply		robotstate			:		robotstate(POS,DIR)

//
//Request  doplan     : doplan( PATH, OWNER, STEPTIME )
//Reply doplandone    : doplandone( ARG ) 
//Reply doplanfailed  : doplanfailed( ARG )


Context ctxbasicrobot ip [host="127.0.0.1" port=8020]
Context ctx_coldstorageservice ip [host="localhost" port=8021]

QActor coldstorageservice context ctx_coldstorageservice {
	
	[#	val maxColdRoom: Float = 10F
		var currentColdRoom: Float = 0F
		
	#]
	
	State s0 initial {
		println("CSS: started") color blue
	}
	Goto waiting
	
	State waiting {
		
	}
	Transition t0	whenRequest	storerequest	->	checkAvail
					whenMsg 	chargetakentt	->	finalizeDeposit
	
	State checkAvail {
		onMsg (storerequest : storerequest(FW)) {
			
			if [# (currentColdRoom + payloadArg(0).toFloat()) <= maxColdRoom #] {
				replyTo storerequest with loadaccepted : loadaccepted
				println("CSS: load ${payloadArg(0)} accepted") color blue
			} else {
				replyTo storerequest with loadrejected : loadrejected
				println("CSS: load ${payloadArg(0)} rejected") color blue
			}
		}
	}
	Goto requestDeposit
	
	State requestDeposit {
				
	}
	Goto finalizeDeposit
	
	
	
	State finalizeDeposit {
		println("CSS: charge taken") color blue
//		updateResource [# "chargetaken" #]
	}
	
}


QActor transporttrolley context ctx_coldstorageservice {
	
	[#	val landmarkConf = utils.MapUtils.loadMapConfiguration("servicearea")
		var lastPos: Pair<Int, Int> = Pair(0,0)
		val HomeToIndoorCoord = landmarkConf.getCoordinateClosestToFor("I", Pair(0,0))
		val IndoorToPortCoord = landmarkConf.getCoordinateClosestToFor("P", HomeToIndoorCoord)
		val PortToHomeCoord = landmarkConf.getCoordinateClosestToFor("H", IndoorToPortCoord)
	#]
	
	State s0 initial {
		println("TT: started") color green
		request basicrobot -m engage : engage(transporttrolley, 330)
	}
	Transition t0	whenReply engagedone	->	setRobot
					whenReply engagerefused	->	engageFailed
					
	State engageFailed {
		//TODO: dobbiamo mettere un protocollo di rifiuto in caso di problemi di engage
	}
	
	State chargeFailed {
		//TODO: dobbiamo mettere un protocollo di rifiuto in caso di problemi di movimento
	}
	
	State setRobot {
		forward basicrobot -m setrobotstate : setpos(0,0,d)
	}
	Goto waiting
		
	State waiting {
		
	}
	Transition t0 whenMsg	deposit	->	moveToIndoorFromHome
				  
	State moveToIndoorFromHome {
		println("TT: moving robot to indoor") color green
		[#	val X = HomeToIndoorCoord.first
			val Y = HomeToIndoorCoord.second
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Transition t0	whenReply moverobotdone		->	chargeTaken
					whenReply moverobotfailed	->	chargeFailed
	
	State chargeTaken {
		forward coldstorageservice -m chargetakentt : chargetakentt
	}
	Goto toPort
	
	State toPort {
		println("TT: charge taken, moving robot to port") color green
		[#	val X = IndoorToPortCoord.first
			val Y = IndoorToPortCoord.second
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Transition t0	whenReply moverobotdone		->	chargeTaken
					whenReply moverobotfailed	->	chargeFailed
					
	State depositInColdRoom {
		delay 1500
		println("TT: charge deposited, returning home") color green
		
	}
	Goto returnHome
	
	State returnHome {
		[#	val X = PortToHomeCoord.first
			val Y = PortToHomeCoord.second
		#]
		request basicrobot -m moverobot : moverobot($X,$Y)
	}
	Goto waitInterrupt
	
	//stato in cui gestire una nuova deposit mentre torna home
	//se non arriva una nuova deposit va in waiting
	State waitInterrupt {
		
	}
	
	
}


ExternalQActor basicrobot context ctxbasicrobot


//QActor transporttrolley context ctx_coldstorageservice {
//	
//	State s0 initial {
//		
//	}
//	Goto waiting
//	
//	State doDeposit {
//		
//		forward basicrobot -m step : step(_)
//		forward basicrobot -m cmd : cmd(_)
//		
//		forward warningdevice -m ledupdate : ledupdate(_)
//		forward servicestatusgui -m statusupdate : updategui(_)
//		
//		delay 3000
//		
//		forward coldstorageservice -m chargetakentt : chargetakentt(_)
//	}
//	Goto waiting
//	
//	State waiting {
//		forward servicestatusgui -m statusupdate : statusupdate(_)
//	}
//	Transition t0 whenTime 2000 -> waiting
//				  whenMsg deposit -> doDeposit
//				  whenMsg stop -> stop
//				  
//	State stop {
//		
//	}
//	Transition t0 whenMsg resume -> resume
//	
//	State resume {
//		returnFromInterrupt
//	}
//	
//}
//
//
//
//
//QActor serviceaccessgui context ctx_access {
//	
//	State s0 initial {
//		request coldstorageservice -m storerequest : storerequest(_)
//	}
//	Transition t0 whenTime 10000 -> s0
//	
//}


